<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>无聊,放牛</title>
  
  
  <link href="/9a8773d558c3f7c29a6a50d2/atom.xml" rel="self"/>
  
  <link href="http://smartyhero.com/"/>
  <updated>2018-06-11T00:00:24.662Z</updated>
  <id>http://smartyhero.com/</id>
  
  <author>
    <name>朱大白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL语句,增删改查</title>
    <link href="http://smartyhero.com/2018/06/10/SQL/"/>
    <id>http://smartyhero.com/2018/06/10/SQL/</id>
    <published>2018-06-10T08:39:19.000Z</published>
    <updated>2018-06-11T00:00:24.662Z</updated>
    
    <content type="html"><![CDATA[<p>SQL语言全称,结构化查询语言,是数据库通用的数据库语言,各个数据库厂商基于SQL标准开发了各自的SQL语言,他们的语法既有共同之处,也各自在一些小的地方有各自不同的之处,这篇文章主要介绍了MySQL/MariaDB使用的SQL语言,且在该文章中由于本人脑子有炮,所以在没有特别申明的情况下MySQL和MariaDB会不加区分的使用</p><a id="more"></a><h3 id="语言规范"><a href="#语言规范" class="headerlink" title="语言规范"></a>语言规范</h3><p>不区分大小写<br>字符串可能会区分大小写<br>可以单行也可以多行,<br>以分号结束<br>关键词不能跨行写<br>可以使用缩进提高阅读性</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>/<em> contents</em>/:多行注释<br>– 注释内容:单行注释–后面有空格<br># MySQL中的注释</p><h4 id="数据库对象命名规则"><a href="#数据库对象命名规则" class="headerlink" title="数据库对象命名规则"></a>数据库对象命名规则</h4><p>必须以字母开头<br>可以包括数字和三个特殊符号,# _ $<br>不要使用MySQL的保留字<br>同一个database中对象不能同名,即使不是同一类型</p><h3 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类:"></a>SQL语句分类:</h3><p><strong>这个分类并不是一个标准的分类,所以不用纠结</strong></p><ol><li>DDL(Data Defination Language):数据定义语言,常用的SQL关键字有create,drop,alter</li><li>DML(Date Manipulation Language):数据操作语言,常用的SQL关键字有insert delet,update</li><li>DCL(Data Control Language):数据控制语言,主要用来操作权限,grant,revoke</li><li>DQL(Data Query Language):数据库查询语言 select</li></ol><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ul><li><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name</span><br><span class="line">[ CHARACTER SET [=] charset_name ]</span><br><span class="line">[ COLLATE [=] collation_name ]</span><br></pre></td></tr></table></figure><p>datebase和schema可以不加区分的使用,if not exists从字面也可以看出,如果这个数据库不存在name就创建它,后面的character set可以设置该数据库默认的字符集,collate可以设置默认的排序规则,</p><p><strong>获取MySQL支持的字符集</strong>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; show charset;</span><br></pre></td></tr></table></figure><p>msyql会显示一个列表给你,有以下字段</p><blockquote><p>Charset:字符集的名称<br>Description:描述信息<br>Default_collation:该字符集使用的默认排序方式<br>Maxlen:单个字符所占的最大字节数</p></blockquote><p><strong>获取所有的排序方式</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; show collation;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; create database blog character set &quot;utf8mb4&quot; collate &quot;utf8mb4_general_ci&quot;</span><br></pre></td></tr></table></figure><p>创建一个名为blog的数据库,默认字符集为utf8mb4,排序规则为utf8mb4_general_ci</p></li><li><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; DROP &#123;DATABASE | SCHEMA&#125; [IF EXISTS] db_name</span><br></pre></td></tr></table></figure><p>这个没有什么需要解释的了,看到删除很多人又激动了,我只想说这是一个老梗了,老用没意思</p></li></ul><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><ul><li><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name</span><br><span class="line">    (create_definition,...)</span><br><span class="line">    [table_options]</span><br><span class="line">    [partition_options]</span><br><span class="line">Or:</span><br><span class="line">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name</span><br><span class="line">    [(create_definition,...)]</span><br><span class="line">    [table_options]</span><br><span class="line">    [partition_options]</span><br><span class="line">    select_statement</span><br><span class="line">Or:</span><br><span class="line">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name</span><br><span class="line">    &#123; LIKE old_tbl_name | (LIKE old_tbl_name) &#125;</span><br></pre></td></tr></table></figure><p>有三种创建方式,第一种手动创建,第二种依照某个现有表创建,且可能会将表中的数据复制过来,第三种也是根据现有表创建,不过只创建表结构</p><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种:"></a><strong>第一种</strong>:</h4><p>temporary表示创建的是临时表,小括号中定义了表结构,多个字段用逗号分隔,每个字段都由字段名开头,然后是数据类型,再然后后跟若干的该字段的属性</p><p><strong>数据类型</strong>,注意,定长数据类型也可以指定长度,不过并不会实际存储的大小,只是显示宽度,在数据类型的选择上如果追求性能可以尽量使用定长的数据类型,如果需要节省空间,则可以考虑变长的数据类型<br><strong>字符型</strong>:</p><pre><code>CHAR,BINARY(区分大小写),定长数据类型VARCHAR,VARBINARY,变长数据类型,TEXT,TINYTEXT,TEXT,MEDIUMTEXT,LONGTEXT,不区分大小写BLOB,TINYBLOB,MDEIDUMBLOB,LONGBLOBENUM,SET</code></pre><p><strong>数值型</strong>:</p><pre><code>精确数值型    整型:TINYINT,SMALLIN,MEDIUMINT,INT,BIGINT    十进制型:DECIMAL近似数值型    浮点型:        FLOAT:        DOUBLE         BIT</code></pre><p><strong>日期时间型</strong>:</p><pre><code>DATE(3B)TIME(3B)DATETIME(8B)TIMESTAMPYEAR(2),YEAR(4)</code></pre><p><strong>常用的属性</strong>:属性可以给每个字段单独设定,也可以在字段定义完成之后使用:属性()在括号中指定拥有该属性的字段比如 primary key(id)</p><p>​    unsigned:无符号,要仅挨着数据类型</p><pre><code>not null:不能为空primary key:主键,一张表只能有一个auto_increment:自增长字段default &quot;value&quot;:默认值unique key:唯一键</code></pre><p><strong>表选项</strong>:table_option:这项可以指定的有很多,这里仅介绍几个</p><p>​    engine=eng_name:设置存储引擎</p><pre><code>default charset:设置默认字符集comment:表描述信息</code></pre><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table weibo (</span><br><span class="line">weibo_id int  not null auto_increment,</span><br><span class="line">user_id int not null,</span><br><span class="line">weibo_content text(800) not null,</span><br><span class="line">img_paths text(65535),</span><br><span class="line">thum_img_path text(65535),</span><br><span class="line">weibo_date date not null,</span><br><span class="line">weibo_time time not null,</span><br><span class="line">weibo_stat int(2) default 1,</span><br><span class="line">    primary key(weibo_id)</span><br><span class="line">)auto_increment=1 engine=innodb default charset=utf8;</span><br></pre></td></tr></table></figure><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>这种方式主要是使用一个查询语句然后会创建一个和查询到的表的结构一样的表,且数据也会被复制过来</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; create table user (select user,host,password from mysql.user);</span><br></pre></td></tr></table></figure><p>这会创建一个user表,该表是仿照mysql数据库中的user表创建的,且创建后数据库中会包含内容,这和括号中的select语句有关,之后还会详细的考察select语句,这里不做过多解释</p><h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种:"></a>第三种:</h4><p>这种方式和上一种一相似,都是根据现有的其他表创建一个新表,只不过他只创建出表,而不会去复制表中的内容</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; create table student like hellodb.students;</span><br></pre></td></tr></table></figure><h5 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">desc table_name</span><br><span class="line">show table status like &quot;table_name&quot; -- 查看某个表的表信息</span><br><span class="line">show table status from &quot;DB_NAME&quot;    -- 查看某个库中所有表的结构</span><br><span class="line">show create table tb_name:          -- 查看表定义</span><br><span class="line">show columns from &quot;table_name&quot;</span><br></pre></td></tr></table></figure></li><li><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER [ONLINE | OFFLINE] [IGNORE] TABLE tbl_name</span><br><span class="line">[alter_specification [, alter_specification] ...]</span><br><span class="line">[partition_options]</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; ALTER TABLE comment ADD group_id INT NOT NULL; -- 添加一列</span><br><span class="line">[blog]&gt; ALTER TABLE comment RENAME TO comments; -- 修改表名</span><br><span class="line">[blog]&gt; ALTER TABLE comments MODIFY group_id int NOT NULL; -- 修改列属性,注意属性要写全,否则可能会丢失以前的属性</span><br><span class="line">[blog]&gt; alter table weibo delete weibo_stat; -- 删除一列</span><br></pre></td></tr></table></figure><p>这里只是列了一些常用的例子,可以仿照例子,进行使用</p></li><li><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROP [TEMPORARY] TABLE [IF EXISTS] tbl_name [, tbl_name]</span><br></pre></td></tr></table></figure></li><li><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tbl_name [(col_name,...)] &#123;VALUES | VALUE&#125; (&#123;expr | DEFAULT&#125;,...),(...),...</span><br><span class="line">Or:</span><br><span class="line">INSERT INTO tbl_name SET col_name=&#123;expr | DEFAULT&#125;, ...</span><br><span class="line">Or:</span><br><span class="line">INSERT INTO tbl_name [(col_name,...)]</span><br><span class="line">    SELECT ...</span><br></pre></td></tr></table></figure><p>插入数据也有三种写法:</p><h5 id="第一种-1"><a href="#第一种-1" class="headerlink" title="第一种"></a>第一种</h5><p>这种方式比较常用,value|values前的括号中指定要向哪个字段中添加数据,其后面的括号中的内容指定要对应前面指定字段添加的值,注意value后只能跟一组值,values后可以跟多组</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; insert into weibo (user_id,weibo_content,weibo_date,weibo_time) value </span><br><span class="line">(2,&quot;hello world&quot;,sysdate(),now());</span><br><span class="line">[blog]&gt; insert into weibo (user_id,weibo_content,weibo_date,weibo_time) values</span><br><span class="line">(2,&quot;hello world&quot;,sysdate(),now()),</span><br><span class="line">(3,&quot;hello MariaDB&quot;,sysdate(),now());</span><br></pre></td></tr></table></figure><h5 id="第二种-1"><a href="#第二种-1" class="headerlink" title="第二种"></a>第二种</h5><p>这种方式有点啰嗦,他是使用set 然后指定字段名等于某个值,因此,稍微会有点麻烦,不过可读性还是不错的</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; insert into weibo set </span><br><span class="line">user_id=5,</span><br><span class="line">weibo_content=&quot;hello linux&quot;,</span><br><span class="line">weibo_date=sysdate(),</span><br><span class="line">weibo_time=now();</span><br></pre></td></tr></table></figure><h5 id="第三种-1"><a href="#第三种-1" class="headerlink" title="第三种"></a>第三种</h5><p>这种方式比较有意思,插入的内容可以是使用select查询到的结果,因此可以批量的插入,前面的写法和第一种一样,只不过在指定完字段名之后,直接写select语句就可以了,需要注意的是select查询到的数据,各字段的数据类型必须和要插入的表的数据类型一致,否则不会成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; insert into weibo (user_id,weibo_content,weibo_date,weibo_time) </span><br><span class="line">select user_id,weibo_content,weibo_date,weibo_time from weibo;</span><br></pre></td></tr></table></figure></li><li><h4 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 单表语法</span><br><span class="line">UPDATE [LOW_PRIORITY] [IGNORE] table_reference</span><br><span class="line">    SET col_name1=&#123;expr1|DEFAULT&#125; [, col_name2=&#123;expr2|DEFAULT&#125;] ...</span><br><span class="line">    [WHERE where_condition]</span><br><span class="line">    [ORDER BY ...]</span><br><span class="line">    [LIMIT row_count]</span><br><span class="line">-- 多表语法</span><br><span class="line">UPDATE [LOW_PRIORITY] [IGNORE] table_references</span><br><span class="line">    SET col_name1=&#123;expr1|DEFAULT&#125; [, col_name2=&#123;expr2|DEFAULT&#125;] ...</span><br><span class="line">    [WHERE where_condition]</span><br></pre></td></tr></table></figure><p>这里仅讨论单表语法,多表我也没玩过,这里需要提醒一下,<strong>更新表如果出错和删库没有什么区别</strong>,所以要格外小心,最大的问题就是不指定条件,如果不指定条件会将表中的该列所有数据进行更新,当然为了防止这种悲剧的发生MySQL还是做了工作的,你可以在配置文件中客户端块中添加safe-update配置,这样当你的更新语句没有条件指定的时候mysql是不会给你更新的,当然如果你是通过编程语言调用的api就要格外注意你用的编程语言调用库有没有给你做这种限制,上面的where,order by,limit就是做限制的,这些内容会放在后面的select中介绍</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; UPDATE comments SET group_id=1 WHERE id=25;</span><br></pre></td></tr></table></figure></li><li><h4 id="删除表中的数据"><a href="#删除表中的数据" class="headerlink" title="删除表中的数据"></a>删除表中的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 单表操作</span><br><span class="line">DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name</span><br><span class="line">    [WHERE where_condition]</span><br><span class="line">    [ORDER BY ...]</span><br><span class="line">    [LIMIT row_count]</span><br><span class="line">-- 多表操作</span><br><span class="line">DELETE [LOW_PRIORITY] [QUICK] [IGNORE]</span><br><span class="line">    tbl_name[.*] [, tbl_name[.*]] ...</span><br><span class="line">    FROM table_references</span><br><span class="line">    [WHERE where_condition]</span><br><span class="line">Or:</span><br><span class="line">DELETE [LOW_PRIORITY] [QUICK] [IGNORE]</span><br><span class="line">    FROM tbl_name[.*] [, tbl_name[.*]] ...</span><br><span class="line">    USING table_references</span><br><span class="line">    [WHERE where_condition]</span><br></pre></td></tr></table></figure><p>删除表和更新表一样,也可以使用safe_update,如果不指定条件也是悲剧</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; delete from comments where id=235;</span><br></pre></td></tr></table></figure></li></ul><h3 id="select语句"><a href="#select语句" class="headerlink" title="select语句:"></a>select语句:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN]</span><br><span class="line">      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]</span><br><span class="line">      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]</span><br><span class="line">    select_expr [, select_expr ...]</span><br><span class="line">    [FROM table_references</span><br><span class="line">    [WHERE where_condition]</span><br><span class="line">    [GROUP BY &#123;col_name | expr | position&#125;</span><br><span class="line">      [ASC | DESC], ... [WITH ROLLUP]]</span><br><span class="line">    [HAVING where_condition]</span><br><span class="line">    [ORDER BY &#123;col_name | expr | position&#125;</span><br><span class="line">      [ASC | DESC], ...]</span><br><span class="line">    [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]</span><br><span class="line">    [PROCEDURE procedure_name(argument_list)]</span><br><span class="line">    [INTO OUTFILE &apos;file_name&apos;</span><br><span class="line">        [CHARACTER SET charset_name]</span><br><span class="line">        export_options</span><br><span class="line">      | INTO DUMPFILE &apos;file_name&apos;</span><br><span class="line">      | INTO var_name [, var_name]]</span><br><span class="line">    [FOR UPDATE | LOCK IN SHARE MODE]]</span><br></pre></td></tr></table></figure><p>上面的内容可能有点乱,我简单解释一下他的语法格式,最简单的select 要查询的字段 from 要从哪个表里面查询,然后在这个基础的格式上做扩展,对查询的结果进行筛选,排序,甚至将查到的结果作为一个临时表,交给另外一个select进行再次查询</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; select * from weibo;  -- *代表所有字段</span><br><span class="line">[blog]&gt; select weibo_id,user_id,weibo_contents from weibo;</span><br></pre></td></tr></table></figure><p>下面就来一点点的扩展:</p><p><strong>where子句</strong>:主要作用是对查到的结果进行过滤,其后面可以写一系列的条件</p><blockquote><p>​    and:并且<br>​    or:或者<br>​    =,!=,&lt;&gt;,&lt;=,&gt;=,&lt;,&gt;:等于,不等于,不等于,小于等于,大于等于,小于,大于<br>​    is NULL:是NULL<br>​    is no null 不是NULL<br>​    between  … and … 从某个小值到某个大值<br>​    not:取反<br>​    xor:异或</p></blockquote><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; select * from weibo; where weibo_id = 5 </span><br><span class="line">[blog]&gt; select weibo_id,user_id,weibo_contents from weibo where weibo_idid &gt; 3 and user_id &lt; 5 ;</span><br></pre></td></tr></table></figure><p><strong>like</strong>:模糊搜索,_代表单个任意字符,%代表任意个任意字符,注意like必须放在where之后</p><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; select * from weibo weibo where weibo_content like &quot;%linux%&quot;;</span><br></pre></td></tr></table></figure><p><strong>group by</strong>:</p><p>分组,这个可能稍微有点难理解,在需要统计功能的时候可以使用,最长用的方法就是在select的时候使用某个函数进行统计某个字段的信息,然后,使用group by对这个字段进行分组,且分组的字段必须是select的字段中的一个</p><p><strong>常用的函数</strong></p><blockquote><p>​    min():求这组值中的最小值<br>​    max():求最大值<br>​    avg():求平均值<br>​    sum():求和<br>​    count():统计个数</p></blockquote><p>了解了这几个常用函数在使用分组时就简单多了,我们可以根据某一个字段进行分组,然后对该字段中相同的内容进行统计</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hellodb]&gt; select ClassID,avg(age) from students group by ClassID;</span><br></pre></td></tr></table></figure><p><strong>order by</strong></p><p>根据指定字段排序,order by [-]col_name {[asc]|desc}:排序,默认升序,asc正序,可以不写,desc,倒叙,-主要控制NULL排在前还是后</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hellodb]&gt; select * from students order by Age;</span><br><span class="line">[hellodb]&gt; select * from students where classid = 1 order by Age;</span><br></pre></td></tr></table></figure><p><strong>limit</strong>:</p><p>limit的主要作用是取数据库中的某一部分,比如说前5行或者8-16行,有两种写法 limit 2表明取前两行,limit 2,3表明从第2行开始取,一共取3行,注意,这里的行是从0 开始的</p><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hellodb]&gt; select * from students limit 6; </span><br><span class="line">[hellodb]&gt; select * from students order by Age limit 6; </span><br><span class="line">[hellodb]&gt; select * from students order by Age limit 2 10;</span><br></pre></td></tr></table></figure><h5 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h5><p><strong>横向连接</strong>:将两个表连接后需要指定where条件,也就是第一张表中的某个字段等于另外一个表的字段连接起来,这样就能将其对应起来了,否则会做笛卡尔乘积,也就是小学学的乘法分配律,注意多表操作的时候要给每个表起别名,在名后使用 as 为其设置别名</p><p><strong>连接类型</strong> </p><blockquote><p>​        inner join … on:内连接,两张表取交集<br>        cross join … on:交叉连接,笛卡尔乘积<br>        left join  … on:左外连接,取左边的表的全部内容和两张表的交集,右表没有的为NULL<br>        right join … on:右外连接,取右边的表的全部内容和两张表的交集,左表没有的为NULL</p></blockquote><p>另外在其他数据库中还有全外连接,但是mysql并没有实现这种操作,因此,此处不作解释</p><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hellodb]&gt; select stu.Name,sco.CourseID from students as stu,scores as sco where stu.StuID=sco.StuID and sco.CourseID in (1,2,4,7);</span><br><span class="line">[hellodb]&gt; select stu.Name,stu.Age from students as stu where stu.age&gt;(select avg(age) from students) group by ClassID;</span><br></pre></td></tr></table></figure><p><strong>纵向连接,</strong>将两个select语句连接起来,让其显示到同一张表中,注意两个select语句的字段数必须一致</p><p>且字段的数据类型也应该一致,union取的是不同的内容,如果想取全部内容可以使用union all</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[blog]&gt; select user,password,host from blog.user </span><br><span class="line">union </span><br><span class="line">select user,password,host from mysql.user;</span><br><span class="line">[blog]&gt; select user,password,host from blog.user </span><br><span class="line">union all </span><br><span class="line">select user,password,host from mysql.user;</span><br></pre></td></tr></table></figure><p><strong>视图</strong>:view,虚表,保存有实表查询到的部分结果,视图本身并不存放数据,其实和别名差不多,只不过是在任何一条SQL语句中都可以使用,其他数据库也有将视图中的数据保存到磁盘中的,但是MySQL并没有<br>        CREATE VIEW view_name  AS SELECT …</p><p><strong>select执行顺序</strong>:from  –&gt; where –&gt; group by –&gt; having –&gt; order by  –&gt; select –&gt; limit</p><h4 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h4><p><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">mysql文档</a><br><a href="http://downloads.mysql.com/docs/refman-5.1-zh.html-chapter.zip" target="_blank" rel="noopener">mysql5.1中文文档官方下载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL语言全称,结构化查询语言,是数据库通用的数据库语言,各个数据库厂商基于SQL标准开发了各自的SQL语言,他们的语法既有共同之处,也各自在一些小的地方有各自不同的之处,这篇文章主要介绍了MySQL/MariaDB使用的SQL语言,且在该文章中由于本人脑子有炮,所以在没有特别申明的情况下MySQL和MariaDB会不加区分的使用&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://smartyhero.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://smartyhero.com/tags/MySQL/"/>
    
      <category term="MariaDB" scheme="http://smartyhero.com/tags/MariaDB/"/>
    
      <category term="SQL" scheme="http://smartyhero.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>ansible</title>
    <link href="http://smartyhero.com/2018/05/31/ansible/"/>
    <id>http://smartyhero.com/2018/05/31/ansible/</id>
    <published>2018-05-31T07:59:47.000Z</published>
    <updated>2018-06-03T06:57:34.404Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible是一款非常优秀的自动化运维工具使用Python语言编写的一个自动化运维工具,是基于模块化开发的,支持自定义模块,可以使用任何语言对其进行扩展,其本身利用了ssh服务,不需要安装客户端,但是效率可能会略差一些,因此可以更加适用于一些中小型的场合,对于一些大型的项目,目前还是有点不太够用的,该软件发布于2012年,在2015年的时候被RedHat收购,在centos系统中可以从epel源中安装它,其源码也维护在了<a href="https://github.com/ansible/ansible" target="_blank" rel="noopener">GitHub</a>上面</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p><strong>单一模块</strong>:这种方式,就是传统的命令方式,通过命令调用模块,执行相应的操作,这个就像我们编程时使用到的一条条语句</p><p><strong>playbook方式</strong>:使用yaml语言把要执行的多个操作编写到同一个文件中,以此来处理一些较复杂的场景,这个就好像组织成了一个函数</p><p><strong>role角色方式</strong>:如果遇到一些比较大且复杂的场景,可以使用ansible提供的角色机制,将任务,变量等操作分门别类的存放到不同的目录下的不同的文件中,最后使用一个playbook文件调用他们,这个就好像最终的一个程序</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><blockquote><p>介绍中说到他是基于ssh协议的,因此在使用前最好做好基于key的认证,在主控端根据用户输入的ansible命令,或者playbook生成一个临时的Python脚本,然后将这个脚本传给被控端在被控端执行完成后还会将这个脚本删除,因此,我们的主控端和被控端都必须有Python的执行环境</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h4><ol><li>yum安装:yum install ansible</li><li>编译安装:</li><li>git方式安装</li><li>pip安装:</li></ol><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>/etc/ansible/ansible.cfg:主配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">配置文件格式为:</span><br><span class="line">    [names]</span><br><span class="line">    key=value</span><br><span class="line">常用配置项项</span><br><span class="line">    remote_tmp:远程存放要执行的Python脚本的位置</span><br><span class="line">    local_tmp:在本地存放临时生成的脚本位置</span><br><span class="line">    forks:并发执行主机的个数</span><br><span class="line">    remote_port:远程主机sshd服务的端口号</span><br><span class="line">    host_key_checking: 是否检查known_hosts文件,可选值为<span class="literal">true</span>,<span class="literal">false</span>,建议设置为<span class="literal">false</span></span><br><span class="line">    log_path:日志文件的位置</span><br></pre></td></tr></table></figure><p>/etc/ansible/hosts: 主机清单文件,将需要管理的主机,只有将主机放在这个文件中才能被ansible管理,可以对主机进行分组,用[]包含分组名,其下面的主机都属于该组,直到文件结尾,或者下一个中括号,主机的表示方式可以是单个IP也可以是192.168.1.[1:10],表示192.168.1.1至192.168.1.10,还可以在此处指定被控端sshd服务的端口可以使用ip:port格式</p><h4 id="可执行程序"><a href="#可执行程序" class="headerlink" title="可执行程序:"></a>可执行程序:</h4><p><strong>ansible</strong>: ansible [host-pattern] [option] [-m module] [-a args],ansible主程序,可以按单一模块方式执行命令</p><p>host-patten:要操作的主机列表,,必须是在主机清单中的主机</p><blockquote><p>​    all:所有主机<br>​    group_name:某一个组,可以使用*进行通配<br>​    group_name1:group_name2:本身为或者的关系,表示组1和组2中的所有的主机<br>​    ‘group_name1:&amp;group_name2’:并且的关系,既出现在组1中又出现在组2中的主机<br>​    ‘group_name1:!group_name2’:出现在组1中但是没有出现在组2中的主机<br>​    ‘~pattern’:使用正则表达式</p></blockquote><p>option</p><blockquote><p>​    –version:版本信息<br>​    -v:显示程序执行过程,-vv,-vvv依次递增详细度<br>​    -m:指定使用的模块<br>​    -k:输入用户名对应的密码<br>​    group_name –list:列出主机清单中定义的该组的所有主机<br>​    -u user_name:指定连接被控端的用户名<br>​    -K:输入sudo口令<br>​    -a ‘arguments…’:指定执行模块的参数<br>​    –list-host:查看都会执行哪些主机</p></blockquote><p><strong>ansible-doc</strong> [option] [modules]:查看模块文档,相当于man帮助</p><blockquote><p>​    -l:列出所有可用模块,即简单说明<br>​    -a:列出所有可用模块和详细文档<br>​    -s:列出模块的简介文档</p></blockquote><p><strong>ansible-galaxy</strong>:管理roles角色,该命令可以从<a href="https://galaxy.ansible.com" target="_blank" rel="noopener">https://galaxy.ansible.com</a>这个网站上下载大神共享的role角色</p><blockquote><p>​    install role_name:安装某个角色,role_name可以从上面的网站上找到<br>​    remove role_name:删除某个角色<br>​    list:列出本机中所有的角色</p></blockquote><p><strong>ansible-playbook</strong>:用于执行playbook,这个命令有一个常用的选项就是-C,这个选项是测试,并不会实际的执行,在写完playbook后可以先用这个命令检查一下</p><p><strong>ansible-vault</strong>:对playbook进行加密</p><blockquote><p>​    encrypt yml_file:加密playbook文件<br>​    decrypt yml_file:解密某个playbook文件<br>​    view yml_file:查看某个加密的playbook文件<br>​    rekey yml_file:修改playbook文件</p></blockquote><p><strong>ansible-console</strong>:ansible的交互式命令执行工具</p><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><p>模块的参数大多数是key=value格式,并且,很多参数是在其他模块中也是可以用的,这里只是列举了常用的模块及常用的选项,如果遇到其他的需求可以查文件ansible-doc</p><p><strong>ping</strong>:用于探测主机是否存活,其本本身并不是使用的ICMP协议,而是使用了ssh协议,会发出一个ping包然后对方存活会回复一个pong包,这个模块也没有什么参数</p><p>示例:</p><p><img src="/images/1527758568418.png" alt="1527758568418"></p><p><strong>command</strong>:执行shell命令,是ansible的默认模块,这个模块不支持变量,管道,重定向等,因此也不太建议使用</p><blockquote><p>​    chdir=/path/to/som_file:切换当前目录<br>​    creates=/path/to/som_file:如果文件存在则不执行<br>​    removes=/path/to/som_file:如果文件不存在就不执行</p></blockquote><p><strong>shell</strong>:也是执行shell命令,最好使用单引号,不能使用别名</p><blockquote><p>​    executeable:指定使用的shell<br>​    chdir=/path/to/som_file:切换当前目录<br>​    creates=/path/to/som_file:如果文件存在则不执行<br>​    removes=/path/to/som_file:如果文件不存在就不执行</p></blockquote><p><strong>copy</strong>:文件复制</p><blockquote><p>​    backup:复制文件到远程主机时,如果存在同名文件,是否备份<br>​    content:文件内容,结合dest使用,在被控端创建内容为其指定的文件<br>​    dest:远程主机上的位置<br>​    src:本机文件的位置<br>​    remote_src:源路径是主控端还是被控端,yes为被控端,no为主控端<br>​    mode:指定权限<br>​    owner:修改属主</p></blockquote><p><strong>fetch</strong>:从被控端复制文件到主控端,目前使用的版本是2.5.3只能复制单个文件,不支持复制目录,不支持通配符,可能会在以后的版本中支持</p><blockquote><p>​    src=/src_dir/file_name:指定要从远程拷贝到本地的文件<br>​    dest=dir:复制到本地的哪个目录下,会在该目录下以远程主机名创建一个目录,然后会在这个目录下创建源路径的全路径</p></blockquote><p><strong>file</strong>:文件管理,不支持文件名通配</p><blockquote><p>​    name:指定文件,目录名称,可以写全路径<br>    src:指定源文件路径<br>    dest:指定目标文件名<br>    state:根据该值进行,创建文件,目录,链接等<br>        touch:对文件进行操作<br>        directory:对目录进行操作<br>        link:对软链接进行操作<br>    absent:删除操作<br>    path:被管理的文件路径<br>    force=yes:强制执行</p></blockquote><p><strong>scirpt</strong>:将本地脚本传到远程进行执行,参数直接写脚本的全路径就可以<br><strong>cron</strong>:计划任务,对于时间,没有定义的默认为*</p><blockquote><p>   ​    minute<br>       hour<br>       month<br>       weekday<br>       job=”command”:要执行的命令,注意命令最好写全路径<br>       name:为计划任务定义个名字<br>   ​    state=absent:删除某个计划任务<br>   ​    disable=true:禁用某个计划任务,可以是true/false也可以是yes/no,底层其实就是将某个计划任务注释了禁用时必须写job和name,否则会新建一个job并将其禁用</p></blockquote><p><strong>yum</strong>:ansible的包管理工具,被控端必须提前配置好yum</p><blockquote><p>   name:指定包名,多个包用逗号隔开,这里可以写rpm包,安装包组要在包名前加@<br>    state<br>        present:默认是这个<br>        installed<br>        lasted安装<br>        absent<br>        removed:卸载<br>    list=installed:查看所有已经装好的包<br>    disable_gpg_check=yes:禁用gpgcheck<br>   update_cache:更新缓存</p></blockquote><p><strong>service</strong>:服务管理</p><blockquote><p>   name:指定服务名<br>    enabled:是否开机启动<br>    state:启动关闭服务<br>   started/stopped/restarted/reload</p></blockquote><p><strong>user</strong>:用户管理</p><blockquote><p>   group:指定主组<br>    groups:指定附加组<br>    remove:删除用户并删除家目录<br>    system:指定系统账号<br>    home:指定家目录<br>    comment:指定描述信息<br>   state=absent:删除用户</p></blockquote><p><strong>group</strong>:组管理</p><blockquote><p>   gid<br>    name<br>    state<br>   system</p></blockquote><p><strong>setup</strong>:显示主机信息</p><blockquote><p>   filter:过滤信息</p></blockquote><h2 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a>Playbook</h2><p>playbook:翻译过来叫做剧本,在一个playbook中将多个模块组合起来,方便使用且条理清晰,比一条一条敲命令省事,playbook文件使用yaml语言编写的,因此文件后缀最后为.yml或者.yaml.这种语言也是一种标记语言,就像HTML,xml,他的格式比较像json,主要格式为key: value1 value2 …,value可以写在同一行,也可以将每一个value写在一行,如果是写在同一行他的冒号后面必须有一个空格,使用-开头的表示是一个列表,严格区分大小写,使用#注释,还有就是他的缩进必须一致切记不要tab和空格混用,相同的缩进代表同一个级别,可以在同一个playbook文件中写多个任务任务之间使用—分隔</p><h4 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span><span class="bullet">--</span><span class="comment">#固定格式,可写可不写</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">hosts/group</span><span class="comment">#横杠后面有空格,冒号后面有空给</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">user_name</span><span class="comment">#指定被控端以哪个用户执行</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  tasks:</span><span class="comment">#作业集,在其下面定义要执行的模块</span></span><br><span class="line"><span class="attr">   - name:</span> <span class="string">hello</span> <span class="comment">#一个作业的名称,任务描述,一个name下只能写一个任务</span></span><br><span class="line"><span class="attr">     module:</span> <span class="string">arguments,...</span> <span class="comment">#执行的模块</span></span><br><span class="line"></span><br><span class="line"><span class="string">示例:</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_usre:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">hello</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">hostname</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hi</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">echo</span> <span class="string">$HOSTNAME</span></span><br></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量:"></a>变量:</h4><p><strong>变量可以定义的位置</strong><br>1.在playbook中定义<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- vars:</span></span><br><span class="line"><span class="attr">  key1:</span> <span class="string">value1</span></span><br><span class="line"><span class="attr">  key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure></p><p>2.在/etc/ansible/hosts文件中为主机或者主机组设置特有的变量,可以为每个主机定义单独的变量,在IP后面使用key=value使用空格分隔定义变量    </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> <span class="string">http_port=80</span> <span class="string">ssh_port=22</span></span><br></pre></td></tr></table></figure><p>3.可以为主机组定义单独的变量,</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[group_name:vars]</span></span><br><span class="line"> <span class="attr">key1:</span> <span class="string">value1</span></span><br><span class="line"><span class="attr">key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure><p>4.在命令中使用-e “key=value”为playbook中的变量赋值,在playbook中使用变量</p><p>5.可以将变量单独定义到一个yml文件中,在playbook中使用var_file: var_filename.yml导入</p><p><strong>变量的使用</strong>:在playbook中使用,格式为,使用两组大括号将变量名包起来,两边最好留一个空格,不是格式要求是为了美观:例如,另外ansible的setup模块定义了关于被控端的信息相关的变量,可以在playbook中直接使用</p><p><strong>变量优先级</strong>:命令行 &lt; playbook &lt; 主机清单,影响的范围越小越优先</p><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器:"></a>触发器:</h4><p>我们在写playbook的时候,有时候希望某一个步骤执行了之后就一定要执行另一步骤,比如说我们修改了服务的配置文件,就一定需要重启其服务,那么我们就可以使用触发器了,使用handlers定义触发后执行的动作,handlers是和tasks同一个级别的,然后可以在tasks中的某一个- name中使用notify模块来定义触发哪个handlers</p><p>示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">test1</span></span><br><span class="line"><span class="attr">      copy:</span> <span class="string">src=httpd.conf</span> <span class="string">dest=/etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="attr">      notify:</span> <span class="string">demo01</span></span><br><span class="line"><span class="attr">  handlers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">demo01</span></span><br><span class="line"><span class="attr">      service:</span> <span class="string">name=httpd</span> <span class="string">state=restart</span></span><br></pre></td></tr></table></figure><h4 id="标签"><a href="#标签" class="headerlink" title="标签:"></a>标签:</h4><p>在使用playbook的时候我们希望只使用其中的一个或者几个动作,这时就可以使用标签了,可以在某一个作业中使用tags: tag_name,来为该作业创建一个标签,然后我们在使用playbook的时候就可以只执行这一个作业,使用 -t tag_name来使用</p><p>示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">test1</span></span><br><span class="line"><span class="attr">      copy:</span> <span class="string">src=httpd.conf</span> <span class="string">dest=/etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="attr">      tags:</span> <span class="string">test1</span></span><br></pre></td></tr></table></figure><p>在使用playbook时我们就可以:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook -t test1 demo.yml</span><br></pre></td></tr></table></figure><h4 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试:"></a>条件测试:</h4><p>主要用到的模块是when,其参数是一个条件表达式,当条件表达式的值为真时就执行当前name下与其同级的模块,否则不执行</p><p>示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">test_when</span></span><br><span class="line"><span class="attr">      service:</span> <span class="string">named=httpd</span> <span class="string">started</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">"6"</span></span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代:"></a>迭代:</h4><p>如果我们要创建三个用户,这样我们就得写三遍只有文件名不同的代码,对于计算机来说这样肯定是挺low的于是ansible提供了解决这类问题的一个方式,可以将文件名定义在with_items中,然后在需要调用的地方用item变量获取</p><p>示例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单示例</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">create</span> <span class="string">file</span></span><br><span class="line"><span class="attr">  file:</span> <span class="string">name=/data/&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">state=touch</span></span><br><span class="line"><span class="attr">  with_items:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">file1</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">file2</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">file3</span></span><br><span class="line"><span class="comment"># 迭代嵌套自变量</span></span><br><span class="line"><span class="attr">- name:</span><span class="string">create</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  user:</span><span class="string">name=&#123;&#123;item.user&#125;&#125;</span> <span class="string">group=&#123;&#123;item.group&#125;&#125;</span></span><br><span class="line"><span class="attr">  with_items:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;user:'user1',group:'g1'&#125;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&#123;user:'user2',group:'g2'&#125;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&#123;user:'user3',group:'g3'&#125;</span></span><br></pre></td></tr></table></figure><p>此时ansible,会依次读取 file1,file2,file3,并将其放在item的位置处,然后执行,注意with_items只能作用于单个name中</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>主要的功能是根据不同主机的系统状态,配置,生成文件,而不是相同的文件,这样我们就有了更强的灵活性,模板文件是一个文本文件,使用jinja2语言编写,文件名后缀最好为.j2该语言有下面的形式:</p><blockquote><p>字符串:使用单引号或者双引号<br>数字:整数,浮点数<br>列表:[item1,item2,…]<br>元组:(item1,item2,…)<br>字典:{key1:value1,key2:value2,…}<br>布尔型:true/false<br>算术运算:+,-,*,/,//(整除),%,**(乘方)<br>逻辑运算:and,or,not<br>流表达式:for,if,when</p></blockquote><p>建议在playbook所在目录创建一个templates目录,专门存放模板文件,这样在playbook文件中直接写文件名就可以了,模板中的变量和playbook使用方式一样</p><p><strong>for循环:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;%for name in list %&#125;</span><br><span class="line">... &#123;&#123; name &#125;&#125; ...</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure><p><strong>if判断:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;%if some is defined %&#125;</span><br><span class="line">something...</span><br><span class="line">&#123;%endif%&#125;</span><br></pre></td></tr></table></figure><h2 id="ROLES角色"><a href="#ROLES角色" class="headerlink" title="ROLES角色"></a>ROLES角色</h2><p><strong>使用</strong>:在系统内的任意目录下创建一个roles目录,然后再在roles目录中创建相应的角色目录,在roles同级目录中创建一个调用角色的文件该文件中写明,主机,使用的用户,然后使用roles: { role: role_name }来指定要执行的角色,role_name就是roles目录中的目录的名称,最后使用ansible-playbook 执行调用文件,以此来执行角色</p><p>角色调用文件示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">role:</span> <span class="string">httpd</span></span><br></pre></td></tr></table></figure><p><strong>角色目录中常见的目录及其作用</strong></p><blockquote><p>tasks:        存放的是按功能编写的playbook文件<br>    main.yml<br>templates:    存放了该角色需要用到的模板文件<br>vars:        变量文件存放的目录<br>    main.yml<br>files:        需要用到的文件存放的目录</p></blockquote><p><strong>目录结构示例:</strong></p><p><img src="/images/1527773881771.png" alt="1527773881771"></p><p><strong>注意</strong>,按上面的命名方式创建目录,在使用角色时,系统会自动的找到相应的目录下的文件,因此,在很多时候,比如说template就不用再写路径了,直接写文件名就可以了,调用角色时系统会自动的找到tasks目录下的main.yml并执行之,因此main文件中多数情况下写的是整个角色的执行流程,可以使用include关键字来将其他的作业文件引入以此来达到调用的效果,而且在对应的目录下写的yml文件,不用再写前面的hosts等内容了就连vars,tasks这些也不用写了,要执行什么就写什么就可以了比如说vars目录中的文件,直接写key=value就可以了,在tasks目录中的文件直接写 -name … module: …就可以了</p><p><strong>角色的标签</strong>:可以有两种,一种是在角色调用文件中设置标签,另外一种是为某一个任务创建标签,可以写在- include的下面,以上两种方式仍可以使用-t选项调用</p><p>角色中设置标签:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- roles:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">roles/httpd/tasks/copyfile.yml,tags:</span> <span class="string">copyfile</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在tasks文件中包含变量可以使用:include_vars: vars_file.yml</p><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档:"></a>相关文档:</h3><p><a href="https://docs.ansible.com/" target="_blank" rel="noopener">官方文档</a></p><p><a href="http://ansible.com.cn" target="_blank" rel="noopener">中文文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ansible是一款非常优秀的自动化运维工具使用Python语言编写的一个自动化运维工具,是基于模块化开发的,支持自定义模块,可以使用任何语言对其进行扩展,其本身利用了ssh服务,不需要安装客户端,但是效率可能会略差一些,因此可以更加适用于一些中小型的场合,对于一些大型的项目,目前还是有点不太够用的,该软件发布于2012年,在2015年的时候被RedHat收购,在centos系统中可以从epel源中安装它,其源码也维护在了&lt;a href=&quot;https://github.com/ansible/ansible&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;上面&lt;/p&gt;
    
    </summary>
    
      <category term="自动化运维" scheme="http://smartyhero.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="自动化" scheme="http://smartyhero.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="ansible" scheme="http://smartyhero.com/tags/ansible/"/>
    
      <category term="工具" scheme="http://smartyhero.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>CentOS系统的自动化安装</title>
    <link href="http://smartyhero.com/2018/05/27/automatic-install-os/"/>
    <id>http://smartyhero.com/2018/05/27/automatic-install-os/</id>
    <published>2018-05-27T05:16:03.000Z</published>
    <updated>2018-05-27T06:04:31.413Z</updated>
    
    <content type="html"><![CDATA[<p>我们平时安装的linux系列的系统大部分使用的安装程序都是anaconda,它有两种显示方式,一种是基于图形界面的,另一种是基于字符界面的,我们平时安装系统通过一系列的点点点,最终其实生成了一个anaconda的配置文件,anaconda会根据这个配置文件中的信息来安装系统,并且安装完系统后会将这个配置文件保存到root家目录中且名为anaconda-ks.cfg</p><a id="more"></a><p>我们其实可以手动生成一个anaconda的配置文件然后将这个文件和安装光盘中的文件放在一起,在安装操作系统的时候,我们通过一些手段指定使用我们自己的配置文件,这样我们就不用一步一步的去选了,让他自动在那里 运行,这样我们就可以去做其他的事情,这也是最简单的自动安装系统方法,下面就来介绍一下,下面以centos7作为实验对象</p><h3 id="系统安装过程"><a href="#系统安装过程" class="headerlink" title="系统安装过程"></a>系统安装过程</h3><p>当计算机选定了光盘的引导位置后,会加载光盘中的isolinux目录下的isolinux.cfg配置文件,之后会根据该配置文件在屏幕上显示一个引导菜单如下</p><p><img src="/images/cdrom-boot.png" alt=""></p><p>我们可以根据我们需要的操作去选择需要执行的操作,注意这个菜单仅是光盘提供的一个配置文件,我们完全可以修改这个配置文件让他以不同方式显示,执行不同的操作,以此让计算机自动的安装一个系统,而且就像grub一样我们也可以在这个地方编辑这些菜单相关的选项,我们只需要选定某个菜单然后按tab键就可以编辑了,如下图所示</p><p><img src="/images/cdrom-tab.png" alt=""></p><p>好像还有点熟悉,第一个肯定是内核文件,第二个指定的应该是伪根文件系统文件,我们可以仅保留下来内核文件名和initrd文件的配置选项,将其他的删了,然后自己指定,在这里我们可以指定在安装系统期间使用的ip地址,以及anaconda的配置文件地址,都可以配置地址了,那anaconda的配置文件肯定是可以放在网络上了,以下对常用的配置选项进行说明:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ip=1.2.3.4<span class="comment"># 在系统安装期间使用的ip地址</span></span><br><span class="line">netmask=255.255.0.0<span class="comment"># 指定子网掩码</span></span><br><span class="line">gateway=1.2.3.1<span class="comment"># 指定网关</span></span><br><span class="line">noipv6   <span class="comment">#不使用ipv6</span></span><br><span class="line">[inst.]ks=    <span class="comment">#指定anaconda配置文件的路径,注意在后续说明中将这个文件称作ks文件,centos7中可能需要inst.</span></span><br><span class="line">[inst.]gpt<span class="comment">#强制系统采用gpt分区格式</span></span><br><span class="line">[inst.]vnc<span class="comment">#在系统安装期间启用vnc服务,方便对安装情况的查看</span></span><br><span class="line">[inst.]sshd<span class="comment">#在系统安装期间启用sshd服务</span></span><br></pre></td></tr></table></figure><p>当然我们也可以上上面的界面中按esc键进入boot:命令行模式,在这里也可以输入这些参数,选项如下示例:</p><p><img src="/images/cdrom-bootcmd.png" alt=""></p><p>你可以将你自己的已经安装好的系统中的anaconda-ks.cfg放到一个http服务器上或者ftp服务器上,然后用光盘引导系统,将ks文件指向你自己的文件路径就可以比较自动的安装一个和你之前系统相关配置一样 的一个系统了</p><p>当然,上面的方法还是挺low的,不但操作不灵活,而且可定制性非常差,下面我们就可以自己定制一个引导菜单,然后制作一个小的引导光盘将这个引导光盘放入计算机后,开机后自动安装一个系统,首先看一下光盘中isolinux/isolinux.cfg这个配置文件的一些关键行</p><blockquote><ul><li>第一行 default vesamenu.c32,定义了引导菜单的风格,vesameun.c32是一个文件,当然这个文件可以被换掉,你可以安装syslinux(记住这个包后面还会用)这个包中会提供其他风格的文件文件会被存储在/usr/share/syslinux/目录中</li><li>第二行的timeout 600这个定义了引导菜单的超时时间,单位为1/10秒,启动后在规定时间后没有进行任何操作就会去执行提前定义好的一个默认的菜单项</li><li>menu title CentOS 7这行定义了顶部显示的内容</li><li>中间的应该都是他的显示格式的定义,下面每一个label定义了一个菜单项</li><li>menu label定义了菜单项的名称 ,可以在任意一个字母前加^表示按该字母自动跳转到该菜单项</li><li>menu default:这个就定义了超时后执行该菜单项,当然,这个选项肯定只能有一个</li><li>kernel vmlinuz:这个定义了内核文件</li><li>append initrd=initrd.img ….这行定义了伪根文件系统文件以及需要添加的一些选项,因此我们就可以在这里添加我们需要添加的选项</li></ul></blockquote><h3 id="制作mini引导光盘"><a href="#制作mini引导光盘" class="headerlink" title="制作mini引导光盘"></a>制作mini引导光盘</h3><p>isolinux目录中的文件都会用到,因此,首先将isolinux目录从光盘中拷贝到其他目录中目录名仍然是isolinux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/myboot</span><br><span class="line">cp -r /mnt/cdrom/isolinux /data/myboot</span><br></pre></td></tr></table></figure><p>然后编辑/data/myboot/isolinux/isolinux.cfg文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/myboot/isolinux/isolinux.cfg</span><br></pre></td></tr></table></figure><p>在append行尾添加ks=/path/to/ks,当然可以是光盘中的文件可以是网络中的文件,注意,如果将ks文件放在了光盘中,在指定是应该写ks=cdrom:/path/to/ks,并且,此时写的绝对路径的根目录应该要制作的光盘的根目录,而不是当前系统的根目录,为了确保正确性,最好写成inst.ks=</p><p>为了美观,还可以删除不需要的菜单项,修改标题,此处不做赘述</p><p>最后制作光盘文件,当然,如果你要将软件包和ks文件也都放在光盘中,这一步还不能执行,需要注意的是-b和-c相对的是制作后光盘的根目录,因此不能写绝对路径,最前面也不能加/,我也不知道为什么不能加/</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V <span class="string">"CentOS 6.9 x86_64 boot"</span> -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/boot.iso /data/myboot</span><br></pre></td></tr></table></figure><p>以上光盘就做好了,由于直接将光盘中的文件拷贝到httpd的工作目录下并不能直接作为这种方式的软件源,因此下面介绍怎样搭建一个软件源,此处基于你的httpd服务已经可以正常使用</p><p>首先将光盘中所有的文件拷贝到httpd的工作目录,或者你要自己创建的光盘的目录</p><p>然后将repodata目录中的非-c6-x86_64-comps.xml结尾的其他文件删除,然后进入到repodata目录下创建元数据注意后面的点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createrepo -g repodata/*-c6-x86_64-comps.xml .</span><br></pre></td></tr></table></figure><p>且所有的TRANS.TBL文件没有用可以将其删除</p><p>最后一步,创建ks文件</p><p>当然我们可以使用上次装系统生成的文件,也可以自己创建,在自己创建时可以利用一个工具system-config-kickstart,不过这是一个图形界面工具,需要开启图形界面使用,由于是图形界面工具,所见即所得,此处不再赘述,不过需要注意的一点是,在给grub设置密码的时候,不要勾选下面的加密,否则在安装时会提示ks文件有问题,当然你不选加密其实他默认是以sha251加密的,反而勾了以后会以md5加密,</p><p>下面介绍一下ks文件中我们会改动到配置项</p><blockquote><p>光盘安装的系统ks文件中会有cdrom选项,如果你的光盘中没有刻录软件那么你就需要把这项删除如果你将文件放在了http站点上,那么你需要使用url –url=<a href="http://some.com/path" target="_blank" rel="noopener">http://some.com/path</a><br>在%package上面使用%post %end将你要在系统安装完成后执行的初始脚本放在里面<br>在centos6安装完系统后会将anaconda-ks.cfg文件中的分区配置注释掉,因此在使用时应该将其打在分区签名最好使用clearpart –all –initlabel表示清除分区信息,初始化标签<br>使用zerombr来清空mbr<br>selinux 和firewall都设置为–disabled可以直接将selinux和firewall关闭</p></blockquote><p>到此,如果没有创建光盘文件,那么创建好光盘文件,就可以引导计算机,装系统了</p><p>以上,我们实现了一个比较自动化的系统安装过程,但是他还不是特别好,假如我们有10台机器需要同时安装相同的系统,我们就需要十个光盘,这样不是很浪费吗,我们发现,在系统引导后就可以配置ip从网络上拿到,那如果系统的引导文件也可以通过网络传输的话,那么只要一开机就可以安装系统了,下面我就来探索一下这种方式</p><h3 id="PXE"><a href="#PXE" class="headerlink" title="PXE"></a>PXE</h3><p>pxe是由intel公司研发的,早些年多用于无盘工作站,主要是在网卡上集成了一个芯片,在开机后会通过dhcp获取到ip地址,通过tftp协议将启动映像下载至本地,然后进行下一步操作,大致过程如下:</p><blockquote><p>客户端开机,使用网卡引导,发送dhcp广播<br>dhcp服务器收到请求,分配ip地址并将tftp服务器ip以及tftp服务器上存放pxe映像文件的位置一并发给客户端<br>客户端收到后会到tftp服务器上请求pxelinux.0文件并加载之<br>加载之后会向tftp服务器请求isolinux.cfg文件<br>读取isolinux.cfg配置文件后会根据文件中的路径继续向tftp服务器请求内核文件和伪根文件系统文件,以及到相应的位置读取ks文件<br>系统开始安装</p></blockquote><p>下面就详细介绍一下dhcp以及dhcp服务</p><h3 id="DCHP"><a href="#DCHP" class="headerlink" title="DCHP"></a>DCHP</h3><p>dhcp服务的前身是bootp服务,该服务主要是为无盘服务器设计的,客户端请求获取一个ip后,服务器会将这个ip和其对应的MAC地址绑定这个ip就只能分配个这mac地址,以便下次该机器访问时还能拿到他的ip以及他自己的数据,但是这个协议有一个缺陷,ip很难复用,因此诞生了dchp,dhcp不仅可以动态的分配ip地址,而且仍然继承了bootp的能力,dhcp是基于先到先得的原则,且整个工作过程基于广播机制实现,因此只能为dhcp服务器所在网段提供服务,要想为其他网段提供服务就必须使用兼容1542标准的路由器或者对路由器进行中继配置才可以实现,支持ipv4和ipv6的地址分配</p><p><strong>dhcp请求步骤</strong></p><blockquote><p>1.客户端使用0.0.0.0地址udp67号端口发一个广播包(255.255.255.255),被称为discover包,寻找局域网内              是否有dhcp服务器<br>2.当dhcp服务器收到这个discover包时,首先从自己的维护的ip池中找到一个自己认为可用的ip地址,然后给这个ip地址发一个ping包,如果没有收到回复则表示这个地址是可用的,然后通过udp68号端口给客户端发送一个offer包,包含该dhcp服务器可以分配的ip地址,及其子网掩码,网关,DNS,以及租期等信息<br>3.客户端收到后发送一个request的请求包,表示我请求使用这个ip<br>4.服务端收到请求后发送一个ACK包进行确认,并且将这个ip记录在已使用的ip列表中<br>5.客户端收到ACK包后将这个ip地址配置为自己的ip地址,此时dhcp请求完成<br>客户端拿到ip后可能还不放心,可能还会发两次arp广播,来确认在该局域网中是否真的没有人使用这个ip</p></blockquote><p><strong>dhcp一些其他的报文</strong></p><blockquote><p>DHCP NAK:服务器到客户端,通知客户端,无法分配合适的ip地址<br>DHCP DECLIENT:客户端到服务器,指示地址已经被使用<br>DHCP RLEASE:客户端到服务器,放弃网络地址和取消剩余的租约时间<br>DHCP INFORM:客户端到服务器端,客户端如果需要从dhcp服务器获取更为详细的配置信息,则发送Inform报文向服务器进行请求,很少用</p></blockquote><p><strong>dhcp服务安装,配置</strong></p><p>dhcp服务的包名就是dhcp因此可以使用yum install dhcp来安装这个软件,当然你也可以利用源代码来编译最新版本的dhcp可以到<a href="http://www.isc.org这个网站上进行下载,对于源码编译,此处不做说明" target="_blank" rel="noopener">www.isc.org这个网站上进行下载,对于源码编译,此处不做说明</a>,</p><p>安装完成后不能立即启用服务,因为它的配置文件是空的,你可以参照/usr/share/dhcp-verison/dhcpd.conf.sample配置dhcp,dhcp的配置文件有两部分,一部分是写在花括号外面的,叫做全局配置,花括号里是局部配置,如果相同的配置项同时出现在两个配置区域中则以局部的为准,下面对一些选项加以说明:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">subnet 子网段 netmask 子网掩码 &#123; <span class="comment"># 子网申明</span></span><br><span class="line">range 起始ip 终止ip;</span><br><span class="line">option router 网关地址;</span><br><span class="line">option domain-name-servers DNS地址(可以写域名多个用逗号隔开);</span><br><span class="line">option domain-name <span class="string">"域后缀"</span></span><br><span class="line">default-lease-time time;<span class="comment">#租期,以秒为单位</span></span><br><span class="line">max-lease-time time;<span class="comment">#最长的租期,客户端可以主动申请租期时长,这个时间规定最长的可以指定的时间</span></span><br><span class="line">next-server:指定tftp服务器位置,用以使空系统获取引导文件</span><br><span class="line">filename <span class="string">"pxelinux.0"</span>:指定引导文件文件名</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">host fantasia &#123; <span class="comment">#ip 和mac绑定,以后这个mac只能拿到这个ip</span></span><br><span class="line">hardware ethernet MAC地址;<span class="comment">#指定mac地址</span></span><br><span class="line">fixed-address ip;<span class="comment">#指定要配置的ip地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外可以使用dhcpd -t命令来检查配置文件是否有误,需要注意的是dhcp配置文件的配置项都是以分号结束的</p><p>下面简单介绍一下tftp:</p><p><strong>TFTP</strong></p><p>这个软件很简单,装上就可以用了tftp服务端包为tftp-server,是一个非独立服务,安装之后也没有多少文件生成:</p><p><img src="/images/tftp.png" alt="tftp"></p><p>其中/var/lib/tftpboot为其工作目录,我们将需要的文件拷贝到这个目录中就可以了./usr/sbin/in.tftpd为其主程序</p><p><strong>基于pxe的系统自动安装环境</strong></p><p><strong>安装配置dhcp</strong></p><p>安装:yum install dhcp</p><p>配置示例:</p><p><img src="/images/dhcp-conf.png" alt="dhcp_conf"></p><p><strong>tftp,及相关文件:</strong></p><p>安装tftp:yum install tftp-server</p><p>安装之后就可以将需要的文件拷贝到其工作目录下了:以下是一个示例<img src="/images/tftpboot.png" alt="tftpboot"></p><p>以下对各个文件及目录进行说明</p><blockquote><p>centos6,centos7两个目录中分别存放了各自版本的内核文件和伪根文件系统文件</p><p>menu.c32文件是引导菜单的风格定义文件,这个风格是一个比较朴素的风格,可以从syslinux包中获取</p><p>pxelinux.0这个文件是pxe的映像文件,也是从syslinux包中获取的</p><p>pxelinux.cfg/defaut文件其实isolinux.cfg文件,这个文件在这里必须以这种目录结构存放</p></blockquote><p>deault文件示例:</p><p><img src="/images/default.png" alt="default"></p><p>​    上文中已经对该文件进行过解释,此处不再赘述</p><p>启动引导文件都完成了,下面开始搭建yum源以及创建ks文件</p><p>这里采用的是httpd服务进行搭建,首先需要安装httpd  yum install httpd,其工作目录为/var/www/html</p><p>在其目录下创建centos6,centos7目录,然后将两个系统的光盘分别挂载,再有就是可以将ks文件也放在这里方便客户端的读取,可以创建一个ks目录,然后将所有的ks文件放在里面,这样我们上面的default文件中的文件路径就可以填写到ks文件的url了</p><p>以下还有一个ks文件示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#platform=x86, AMD64, or Intel EM64T</span></span><br><span class="line"><span class="comment">#version=DEVEL</span></span><br><span class="line"><span class="comment"># Install OS instead of upgrade</span></span><br><span class="line">install</span><br><span class="line"><span class="comment"># Keyboard layouts</span></span><br><span class="line">keyboard <span class="string">'us'</span></span><br><span class="line"><span class="comment"># Root password</span></span><br><span class="line">rootpw --iscrypted <span class="variable">$1</span><span class="variable">$lcyC9YYj</span><span class="variable">$k</span>/ClrtPKixN200FXgcc/M1</span><br><span class="line"><span class="comment"># Use network installation</span></span><br><span class="line">url --url=<span class="string">"http://192.168.132.254/centos7/"</span></span><br><span class="line"><span class="comment"># System language</span></span><br><span class="line">lang en_US</span><br><span class="line"><span class="comment"># Firewall configuration</span></span><br><span class="line">firewall --disabled</span><br><span class="line"><span class="comment"># System authorization information</span></span><br><span class="line">auth  --useshadow  --passalgo=sha512</span><br><span class="line"><span class="comment"># Use text mode install</span></span><br><span class="line">text</span><br><span class="line"><span class="comment"># SELinux configuration</span></span><br><span class="line">selinux --disabled</span><br><span class="line"><span class="comment"># Do not configure the X Window System</span></span><br><span class="line">skipx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Network information</span></span><br><span class="line">network  --bootproto=static --device=ens33 --ip=192.168.132.32 --netmask=255.255.255.0</span><br><span class="line"><span class="comment"># Reboot after installation</span></span><br><span class="line">reboot</span><br><span class="line"><span class="comment"># System timezone</span></span><br><span class="line">timezone Asia/Shanghai</span><br><span class="line"><span class="comment"># System bootloader configuration</span></span><br><span class="line">bootloader --location=mbr --password=<span class="string">"123456"</span></span><br><span class="line"><span class="comment"># Clear the Master Boot Record</span></span><br><span class="line">zerombr</span><br><span class="line"><span class="comment"># Partition clearing information</span></span><br><span class="line">clearpart --all --initlabel</span><br><span class="line"><span class="comment"># Disk partitioning information</span></span><br><span class="line">part /boot --fstype=<span class="string">"xfs"</span> --size=500</span><br><span class="line">part swap --fstype=<span class="string">"swap"</span> --size=2048</span><br><span class="line">part / --fstype=<span class="string">"xfs"</span> --grow --size=1</span><br><span class="line"></span><br><span class="line">%post</span><br><span class="line">mkdir /root/.ssh</span><br><span class="line">mkdir /etc/yum.repos.d/bak</span><br><span class="line">mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak</span><br><span class="line">cat &gt; /etc/yum.repos.d/base.repo &lt;&lt;EOF</span><br><span class="line">[base]</span><br><span class="line">name=base repo</span><br><span class="line">baseurl=http://192.168.132.254/centos7/</span><br><span class="line"><span class="built_in">enable</span>=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">EOF</span><br><span class="line">yum install wget</span><br><span class="line">wget http://192.168.132.254/files/id_rsa.pub -O /root/.ssh/authorized_keys</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%packages</span><br><span class="line">@base</span><br><span class="line">@core</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>至此,环境基本搭建完成,可以在相同网段中,最好使用虚拟机测试一下,当然,肯定会遇到各种各样的坑的,遇到之后,你可以根据上面描述的pxe的工作过程,来排除错误</p><p>当你觉得上面的搭建过程过于繁琐时,且有想自己写一键部署脚本的想法时,那么你是一个挺合格的计算机相关工作者,不过其实早已有人实现了,而且使用python写出来的,那就cobbler,不过这个工具在centos的epel源中,安装cobbler的同时会为你安装httpd和tftp,而且都由cobbler统一管理,工具很好用,不仅支持命令行管理方式还提供web界面的管理方式,web界面管理还需要安装cobbler-web,命令行的方式也是比较容易操作的,安装完成后只需要执行cobbler check它就会自动检查你的环境,然后会给你提出一些建议,让你去配置,当然,有些配置对当前环境是没有用的也就不用理他了</p><p>cobbler的配置文件是/etc/cobbler/setting,你还可以将你的dhcp服务也交由cobbler管理,只需要将配置文件中的manage_dhcp设置为1,然后他提供了一个配置模板,/etc/cobbler/dhcp.template,你之需要修改一下这个模板就可以了修改完之后然后执行cobbler sync命令进行配置文件的同步,</p><p>下面对一些常用的cobbler命令做以说明:</p><blockquote><p>导入源文件cobbler import –path=/mnt/some/repo –name=centosN –arch=x86_64,文件导入后默认存放到/var/www/cobbler中<br>导入后系统会自动生成应答文件,且为最小化安装方式安装<br>cobbler distro list:列出当前配置好的安装系统<br>cobbler distro remove –name=centosN删除某一个菜单项<br>cobbler profile add –name=centosName –distro=name –kickstart=/var/lib/cobbler/kickstarts/cfgfile:导入自己自定义的应答文件,注意将应答文件放入/var/lib/cobbler/kickstarts/目录中然后再进行导入操作,在应答文件中软件源的url不用自己指定,可以用一个cobbler的模块来替代$tree</p></blockquote><p>关于系统的自动化安装就介绍到这里</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们平时安装的linux系列的系统大部分使用的安装程序都是anaconda,它有两种显示方式,一种是基于图形界面的,另一种是基于字符界面的,我们平时安装系统通过一系列的点点点,最终其实生成了一个anaconda的配置文件,anaconda会根据这个配置文件中的信息来安装系统,并且安装完系统后会将这个配置文件保存到root家目录中且名为anaconda-ks.cfg&lt;/p&gt;
    
    </summary>
    
      <category term="自动化运维" scheme="http://smartyhero.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="自动化" scheme="http://smartyhero.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="系统" scheme="http://smartyhero.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="dhcp" scheme="http://smartyhero.com/tags/dhcp/"/>
    
  </entry>
  
  <entry>
    <title>CentOS系列操作系统启动</title>
    <link href="http://smartyhero.com/2018/05/20/System-Start/"/>
    <id>http://smartyhero.com/2018/05/20/System-Start/</id>
    <published>2018-05-20T05:26:07.000Z</published>
    <updated>2018-05-20T07:46:57.992Z</updated>
    
    <content type="html"><![CDATA[<p>首先,本文会介绍CentOS5的启动流程,接下来会对比CentOS5介绍CentOS6和CentOS7的启动流程,注意文中介绍的都是BIOS+MBR格式分区的启动方式</p><a id="more"></a><h2 id="CentOS5系统启动流程"><a href="#CentOS5系统启动流程" class="headerlink" title="CentOS5系统启动流程"></a>CentOS5系统启动流程</h2><ol><li><p><strong>POST加电自检</strong></p><blockquote><p>检测计算机各个硬件是否处于正常状态,如果正常则继续执行,后面的操作,如果有些部件不正常,主办上的蜂鸣器可能会发从警告声,</p></blockquote></li><li><p><strong>选择引导设备</strong></p><blockquote><p>根据设定好的系统加载次序,依次扫描各个加载设备,直到找到第一个可以加载的磁盘设备,</p></blockquote></li><li><p><strong>grub第1阶段</strong></p><blockquote><p>读取上一步找到的磁盘设备的第0磁道第0扇区(也就是MBR)的前446字节,这一部分称做引导加载器即BootLoader</p></blockquote></li><li><p><strong>grub1.5阶段</strong></p><blockquote><p>该步骤是通过上一步的指示,读取bootloader的后n个扇区,该部分主要存放了用以加载boot分区的程序</p></blockquote></li><li><p><strong>grub2阶段</strong></p><blockquote><p>此时就可以加载boot分区了,加载之后会读取grub目录中的grub.conf配置文件,这个文件中定义了默认的启动项以及grub菜单的显示时间,内核文件(vmlinuz)的位置(支持多个内核),根分区的位置,伪根分区文件(initrd)等等,之后就可以在屏幕上看到grub的启动菜单了,在此选择需要启动的内核,选择后,grub会将整个计算机的控制权交给内核,此时grub使命完成</p></blockquote></li><li><p><strong>内核初始化</strong></p><blockquote><p>加载内核后首先会尝试根据grub,中的配置尝试以只读的方式去挂载根分区,因为没有根分区磁盘驱动程序等原因造成根分区挂载失败,则会将initrd文件载人内存使其临时成为根分区,内核通过根分区中的工具,文件等进行自身的初始化</p></blockquote></li><li><p><strong>启动第一个进程/sbin/init</strong></p><blockquote><p>内核初始化完成,开始尝试启动第一个进程/sbin/init,该程序在CentOS5中由SysVinit程序提供该进程会进行一系列的系统初始化动作</p><ol><li>读取/etc/inittab文件,以下详细解释文件中各部分的作用<ul><li>id:3:initdefault:,确定系统启动的运行级别,中间的数字代表不同的运行级别,0:关机,1:单用户模式:没有NFS服务的多用户模式,3:命令行模式的多用户模式,4:保留,暂未使用,5:图形界面模式,6:重启,在进入系统后可以使用init N来手动改变运行模式</li><li>si::sysinit:/etc/rc.d/rc.sysinit,系统初始化脚本,该脚步中又完成了一系列的动作,比如定义主机名,设置欢迎信息,激活selinux,挂载/etc/fstab文件中定义的文件系统(这里可能会伪根文件系统切换成真正的根文件系统),导入/etc/init.d/functions文件(该文件中定义了一系列的函数,方便在初始化时使用,)检查selinux状态,启动swap分区等等一列的操作,这里不再一一列举</li><li>l0:0:wait:/etc/rc.d/rc 0:会有7条这样的语句,每条代表一个运行级别,第2列的数字代表的是运行级别,最后一个数字是传给/etc/rc.d/rc脚本的参数,代表的是对应的运行级别,该脚本会根据传给他的对应的运行级别来启动关闭该级别中需要关闭,启动的服务,其工作原理很简单,执行了/etc/rc.d/rcN.d/中的脚本(N代表对应的运行级别数字),其实是指向//etc/init.d/中的对应服务启动脚本的软链接,这些软链接的名字是按规定格式写的,以K或者S,中间是两位数字最后是服务的名称,K代表该运行级别中不启动的服务,S代表该运行级别中需要启动的服务,中间的两位数字可以控制服务的启动与关闭的顺序,因为某写服务会依赖于其他的服务,因此需要有顺序的控制,最后会有一个特殊的文件S99local,这个软链接没有指向服务启动脚本而是指向了/etc/rc.local,由于是99因此它会最后一个执行,用户可以在这个文件中写一些系统启动时需要执行的命令,,由此,其实我们在执行chkconfig命令启用或者关闭某个服务开机启动时其实就是在修改这些快捷方式的名称,以上介绍可以看出,不同的运行级别,其实就是启动不同的服务而已,</li><li>ca::ctrlaltdel:/sbin/shutdown -t3 -r now:,监听ctrl+alt+del按键,当三个按键同时按下时,系统会重新启动,为了防误触,可以注释掉该行</li><li>pf::powerfail:/sbin/shutdown -f -h +2 “Power Failure; System Shutting Down”,这一行定义了,当计算机断电接入ups电源后,会在两分钟内关机,</li><li>pr:12345:powerokwait:/sbin/shutdown -c “Power Restored; Shutdown Cancelled”,这个功能是当接入ups后,来电后会取消上面定义的关机操作</li><li>1:2345:respawn:/sbin/mingetty tty1,默认会有6行,即系统启动后会启动6个tty终端(即使用ctrl+alt+f[1-6],可以切换终端),可以人为的删除增加行,来增减这个数值,其中respawn表示该进程如果被终止,系统会立即生成一个新的进程,即保证永远有n个tty终端</li><li>x:5:respawn:/etc/X11/prefdm -nodaemon:这一行定义了哪一个运行级别属于图形界面,至此系统启动完成</li></ul></li></ol></blockquote></li></ol><h2 id="CentOS6与CentOS5对比"><a href="#CentOS6与CentOS5对比" class="headerlink" title="CentOS6与CentOS5对比"></a>CentOS6与CentOS5对比</h2><blockquote><p>其实在内核启动之前所有的步骤都没有什么变化,不过,虽然系统启动的第一个进程也是/sbin/init但是在centos6中的init程序却悄悄的发生了一些变化,centos6中的init程序由upstart程序提供,该程序其实是ubuntu开发的,以此可见,只有同行才是赤裸裸的仇恨这句话也不是那么的准确,upstart的启动过程略有不同,在/etc/inittab文件中仅定义了系统启动的运行级别,其他的配置都放在了/etc/init/*.conf中了,不过它还是会运行/etc/rc.d/rc.sysinit脚本的,upstart与SysVinit最大的区别是在开机时服务的启动上提高了速度,在CentOS5中服务只能是前一个服务启动完成后后一个服务才可以启动,这样其实并没有多大必要,因为好多服务是没有依赖关系的,因此在CentOS6中对于这些没有依赖关系的服务,在启动时是可以并行启动的,这样就加快了启动的速度</p></blockquote><h2 id="CentOS7与CentOS6的对比"><a href="#CentOS7与CentOS6的对比" class="headerlink" title="CentOS7与CentOS6的对比"></a>CentOS7与CentOS6的对比</h2><blockquote><p>在CentOS7中系统的启动有了不小的改变,首先是grub,从之前centos5,6使用的grub0.9直接升级到了grub2,系统启动的第一个进程也由init改成了Systemd,这个systemd的功能实在是太强大了(据说systemd主要借鉴了Mac的OSX系统的启动方式),服务的启动,系统的运行级别,磁盘的挂载统统可以由systemd来完成,在systemd中这些不同的功能被定义成不同的Unit,服务被叫做service,运行级别被叫做target,已经有了一种systemd一家独大的感觉了,不过,最主要的是,CentOS7的开机启动效率又被大大的提高了少,CentOS7将多数的有依赖关系的服务的启动也做了优化,大概的运行机制是在系统启动时,先将被依赖服务打一个已经启动的标签,这样需要依赖他的服务就可以差不多的和它同时启动</p></blockquote><p>最后,以上这些内容为个人总结而来,可能会有很多不妥的地方,再以后觉得不妥的地方还会更新,修改</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先,本文会介绍CentOS5的启动流程,接下来会对比CentOS5介绍CentOS6和CentOS7的启动流程,注意文中介绍的都是BIOS+MBR格式分区的启动方式&lt;/p&gt;
    
    </summary>
    
      <category term="Linux基础" scheme="http://smartyhero.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="linux" scheme="http://smartyhero.com/tags/linux/"/>
    
      <category term="系统启动" scheme="http://smartyhero.com/tags/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>vi编辑器</title>
    <link href="http://smartyhero.com/2018/05/17/vi-vim/"/>
    <id>http://smartyhero.com/2018/05/17/vi-vim/</id>
    <published>2018-05-17T10:51:19.000Z</published>
    <updated>2018-05-17T11:00:23.896Z</updated>
    
    <content type="html"><![CDATA[<p>有一少部分人人觉得这是装逼,而有些人则默默的使用他完成自己的种种文本处理工作,<br><a id="more"></a>​<br><img src="/images/vi-vim-cheat-sheet-sch.gif" alt=""><br>    <strong>用过Linux应该没有不知道vi/vim编辑器的吧,它是一款功能特别强大的文本编辑软件,第一次看到这个工具的介绍时,我都震惊了,在只能输英文字母的界面上我们还可以这样操作,同时也对软件的设计者有着深深的崇拜之情,原谅我的词穷,无法用文字来表达我对这款软件的喜爱之情,vim是vi的增强版,由于本人一直都用的是vim,所以以下都是对于vim的介绍,当然vim只是比vi增加了不少功能,软件的作者是一个叫布莱姆·米勒的荷兰程序员在1991年发布的,这个软件其实在Windows下也可以使用,其源代码现在也托管在GitHub上面:<a href="github.com/vim/vim">github.com/vim/vim</a>官方网站为:<a href="www.vim.org">www.vim.org</a>下面就简单的总结一下这个软件的使用方法</strong></p><p>首先要介绍一下vim的三种模式:<strong>命令模式,编辑模式,扩展命令模式</strong></p><p>​    <strong>命令模式</strong>:是vim的默认模式,在这个模式下你可用一些特定含义的字符来进行复制,粘贴,定位光标等一系列操作</p><p>​    <strong>插入模式</strong>:这个容易理解了,就是编辑文本文件</p><p>​    <strong>扩展命令模式</strong>:这个主要是可以输入一些vim自有的命令,来完成一些高级功能</p><p>想要使用vim打开一个文件非常简单,只需要在命令提示符中输入<em>vim file_name</em>即可打开,当然vim打开的时候也可以使用一些特定的选项:</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-d</td><td>打开多个文件做比较</td></tr><tr><td>-m</td><td>以只读方式打开</td></tr><tr><td>-e</td><td>直接进入扩展命令模式</td></tr><tr><td>+n</td><td>打开后光标定位到第n行</td></tr><tr><td>+pattern</td><td>打开光标后定位到第一个匹配到行的位置</td></tr></tbody></table><p>在打开的时候默认进入的是vim的命令模式,下面就详细的介绍各个模式下的操作:</p><p>​    <strong>命令模式</strong></p><p>​    首先介绍一下进入编辑模式的几种操作:</p><blockquote><p>​        i:进入到插入模式</p><p>​        I:进入到插入模式,并且光标移动到行首</p><p>​        a:进入插入模式后,光标移动到后一个字符</p><p>​        A:进入插入模式后,光标移动到行尾</p><p>​        o:切换到插入模式,并且在当前行下方插入一个空行,并且光标移动到空行</p><p>​        O:这个就很简单了,在当前行上方插入空行</p></blockquote><p><strong>注意</strong>:现在的设定还是在命令模式下,再介绍一些其他的操作</p><p><strong>光标跳转:</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>h,j,k,l:</td><td>这四个字母分别代表,光标向左,下,上,右移动,虽然看起来没有什么规律,其实他是在你键        盘右手自然放置的位置,我们还可以在按下这几个字母之前加一个数字,就代表移动若干行或字符,比如说向上移动5行可以按,5k,下面的介绍中很多都支持这种操作,以下就把这种操作叫NCOMMAND操作(这是我自己起的).</td></tr><tr><td>w</td><td>光标移动到下一个单词的词首,支持NCOMMAND操作</td></tr><tr><td>e</td><td>光标移动到下一个单词的词尾,如果光标不在当前单词词尾则第一次移动到当前单词词尾,支持NCOMMAND操作</td></tr><tr><td>b</td><td>光标移动到当前单词词首或上一个单词词首,支持NCOMMAND操作</td></tr><tr><td>^</td><td>移动到当前行非空格的行首</td></tr><tr><td>0</td><td>移动到行首</td></tr><tr><td>$</td><td>移动到行尾</td></tr><tr><td>nG</td><td>跳转到第n行</td></tr><tr><td>G</td><td>跳转到末尾行</td></tr><tr><td>H</td><td>光标跳转到当前屏幕的最上面</td></tr><tr><td>L</td><td>光标跳转到当前屏幕的最下面</td></tr><tr><td>M</td><td>光标跳转到当前屏幕的中间</td></tr><tr><td>Ctrl+f</td><td>向后翻一屏</td></tr><tr><td>Ctrl+b</td><td>向前翻一屏</td></tr><tr><td>Ctrl+d</td><td>向后翻半屏</td></tr><tr><td>Ctrl+u</td><td>向文件首部翻半屏</td></tr></tbody></table><p><strong>编辑命令:</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>x</td><td>删除(其实是剪切)光标处的字符,支持NCOMMAND操作</td></tr><tr><td>p</td><td>粘贴</td></tr><tr><td>xp</td><td>交换光标和光标后面字符的位置</td></tr><tr><td>d</td><td>剪切命令,如果不粘贴就实现了删除操作单是一个d没有任何效果,可以结合上面的跳转命令剪切字符或者行,支持NCOMMAND操作</td></tr><tr><td>d$</td><td>从当前位置剪切到行尾,,NCOMMAND示例:5d$,从当前位置删除到下5行尾</td></tr><tr><td>d0</td><td>从当前位置剪切到行首</td></tr><tr><td>dw</td><td>剪切到下一个单词首,支持NCOMMAND操作</td></tr><tr><td>de</td><td>剪切到单词尾,支持NCOMMAND操作</td></tr><tr><td>db</td><td>剪切到单词首,,支持NCOMMAND操作</td></tr><tr><td>y</td><td>复制命令,和d命令操作逻辑一样,这里就不再一一列举了</td></tr><tr><td>yy</td><td>复制一整行</td></tr><tr><td>cc</td><td>删除当前行,并进入编辑模式,支持NCOMMAND操作</td></tr><tr><td>u</td><td>撤销命令,支持NCOMMAND操作</td></tr><tr><td>U</td><td>恢复当前行,使之成为编辑前的状态,当然移动光标后就不能使用该操作了</td></tr><tr><td>Ctrl+r</td><td>撤销上一个撤销操作</td></tr><tr><td>.</td><td>重复前一个操作</td></tr></tbody></table><p>以上就是一些经常会用到的命令,下面开始介绍扩展命令模式</p><p>想进入扩展命令模式其实特别简单,只要在命令模式下输入:就进入了扩展命令模式了,你会发现在屏幕的左下方会有一个冒号在冒号后面就可以输入命令了,输入完成之后按回车键执行,接下来就介绍一些经常会用到的命令</p><p><strong>地址定界</strong>:就是在扩展命令下定位光标位置,以及对文件中的哪些行进行操作</p><p>​    n:定位到第n行</p><p>​    m,n:从第m行到地n行,当需要编辑这几行的内容时可以这样写</p><p>​    n,+m:从当前行开始之后的m行</p><p>​    .:表示当前行</p><p>​    $:表示最后一行</p><p>​    %:全文</p><p>​    /pattern1/,/pattern2/:从第一个模式匹配到的第一行到第二个模式匹配到的第一行</p><p>​    地址定界之后可跟上面的编辑命令,比如1,5d表示删除第一到五行</p><p><strong>另存文件</strong>:</p><p>​    w /path/to/newfile 将文件另存到其他地方,当然前面也可以跟地址定界,把指定的行存到另外的文件中</p><p>​    r /path/to/otherfile 将另外文件中的内容读取到当前行</p><p><strong>替换</strong>:这个也是经常会用到的</p><p>​    %s/a/b/可选选项</p><p>​    前面也可以跟地址定界,s是关键字/是分隔符,可以用其他字符表示,a是要替换的内容,可以使用正则表达式b是替换为的内容&amp;前面要替换的内容,可选选项主要有i,g.i表示忽略大小写g表示全局替换,默认情况下,在一行中替换了一次就不再在该行中进行替换了,g可将该行中所有符合的都替换</p><p>下面再介绍几个<strong>配置vim特性</strong>的常用命令</p><p>​    显示行号:set number,可以简写为set nu,如果想取消可以使用set nonu</p><p>​    高亮括号匹配:set showmatch 简写为set  sm</p><p>​    自动缩进:set ai</p><p>​    高亮搜索结果:set hlsearch</p><p>​    语法高亮:syntax on/off</p><p>​    忽略字符大小写:set ic</p><p>这里只是列举了几个,还有很多很多,当然这样中配置只能在当前vim进程中有效,如果想全局有效的话当然是得写入到vim的配置文件中了,对于vim也不例外有两个配置文件,个人~/.vimrc和全局配置文件/etc/vimrc,你可以查阅官方文档来对vim进行你自己的个性化定制</p><p>另外介绍vim的一个炫技的技能:打开多个文件,可以使用vim后加多个文件名来打开多个文件,当然打开的时候显示的是第一个文件可以使用:next切换到下一个文件,:prev切换到上一个文件:first切换到第一个文件,:last切换到最后一个,:qall退出所有文件,:wall保存所有,:wqall保存并退出所有,如果你觉得这种方法不好用可以在打开时使用-o或-O选项来打开文件,这样文件就会以水平或者垂直的方式显示在同一个屏幕上,如下图:</p><p><img src="/images/vim01.png" alt=""></p><p>当然这时我们还需要另外一个技能就是将光标切换到不同的窗口中,那就可以用Ctrl+w然后按上下左右键切换到不同的窗口中</p><p>如果你觉得vim非常难学,那么作者还非常贴心的写了一个练习工具:vimtutor,打开之后是一个vim的说明文档,当然是用vim打开的,你可以在里面边看文档边的折腾他,</p><p>最后总结一下,vim的强大之处关键的一点在于他的命令可以组合着使用,比如你在编辑模式下输入了一个单词后,然后返回到命令模式输入100然后按下.他就会将你刚才输入的那个单词重复100遍</p><p>最后再展示几张网上找到的vim的键位图:</p><p><img src="/images/advanced1.png" alt=""></p><p><img src="/images/entry1.png" alt=""></p><p><img src="/images/morden1.png" alt=""></p><p><strong>参考资料</strong></p><p>​    <a href="http://vimcdoc.sourceforge.net/vim_user_manual_603.0.pdf" target="_blank" rel="noopener">一个中文的vim文档</a></p><p>​    <a href="http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html" target="_blank" rel="noopener">开头的图片</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一少部分人人觉得这是装逼,而有些人则默默的使用他完成自己的种种文本处理工作,&lt;br&gt;
    
    </summary>
    
      <category term="Linux基础" scheme="http://smartyhero.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="linux" scheme="http://smartyhero.com/tags/linux/"/>
    
      <category term="vi" scheme="http://smartyhero.com/tags/vi/"/>
    
      <category term="编辑器" scheme="http://smartyhero.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>程序包管理 rpm/yum/源码编译</title>
    <link href="http://smartyhero.com/2018/05/17/yum-rpm/"/>
    <id>http://smartyhero.com/2018/05/17/yum-rpm/</id>
    <published>2018-05-17T10:50:51.000Z</published>
    <updated>2018-05-17T10:59:08.278Z</updated>
    
    <content type="html"><![CDATA[<p>​    在Windows中装软件是特别轻松的事情,基本上下载一个exe的程序,然后双击,下一步就可以成功了,那么面对纯命令行接口的Linux,我们想装一个程序的话就需要使用相应的命令了,利用vim编辑文件都那么容易,装个软件包肯定不在话下,这篇文章主要总结一下Linux下程序包管理相关工具使用,以及相关的原理<br><a id="more"></a><br>​    对于开发人员或者是IT技术从业人员来说,喜欢Linux与OSX的原因我认为一部分的原因为,这两个家伙,你想去使用它必须了解一些其相关的工作原理,才能很好的使用它.这是一个多么好的学以致用的机会呀.那么首先就来了解一个算是常识性的东西吧,就是exe程序为什么在Linux下不能运行,首先需要介绍两个软件运行环境一个叫做ABI(Application Binary Interface)另一个叫做API(Application Programming Interface),一个叫做应用二进制接口,另一个叫做应用程序接口,这里不做详细的解释,因为我目前理解的状态还不够我来完全解释,最主要的就是在Windows和Linux中这两个接口的实现方式不相同,导致了程序无法跨平台来运行</p><p>​    在Linux中一个程序主要包含了,二进制文件,库文件,配置文件,帮助文档,当然也不是所有的程序都包含这些内容,程序包其实就是将这些文件进行打包,那安装程序包,其实就是将这个软件包解压,然后移动到相应的目录中,当然,安装前需要探测一下当前的环境是否满足软件包的需要,当然不只是去检测一下这个软件包是否安装,而是这个软件包中的二进制程序在开发时需要用到很多的库,如果当前系统没有有这个库,那么软件安装就会报错,这里说到了库,库其实就是一个个的功能模块,比如连接网络等等可能会觉得程序包不是自带了吗,然而并不是这样,程序自带的其实是程序自己使用的库,还有一些库是需要在执行时动态调用系统的库,这些库都封装的是公共的功能模块,也就是说可能很多程序会用到,这样就不同每个程序都自带一个这样的库了,那样就太累了,</p><p>​    说了这么一堆,也不知道说明白没有,其实想说的就是,在安装很多软件包的时候会发生一个特别恶心的事情就是,软件有依赖关系,最常见的就是依赖某些库,这就会导致软件的安装失败,当然,这个问题早已有了解决方案,</p><h3 id="RPM包管理器"><a href="#RPM包管理器" class="headerlink" title="RPM包管理器"></a>RPM包管理器</h3><p>​    在Redhat系列的Linux平台上软件包的后缀名为rpm,当然还有一个用于安装rpm包的工具叫做rpm,这个工具没有解决依赖关系的功能,废话说了一箩筐,下面就来介绍一下怎样使用这个工具来,安装,卸载,更新软件包</p><p><strong>安装:</strong>rpm {-i|–install} [install-options] PACKAGE_FILE …</p><p>​    首先来个小demo,也是最常用的就是安装,rpm -ivh PACKAGE_FILE,-i是最主要的,就是安装,v就是显示安装的详细信息,h的作用是用#显示进度,PACKAGE_FILE就是软件包文件的文件名,用rpm安装必须要先把rpm包下载到本地,当然其实大部分常用的软件包都已经放在了CentOS的安装光盘中了</p><p>下面就拉详细介绍一下一些常用参数:</p><p>​    -vv:显示更加详细的信息</p><p>​    –test:这个选项好,可以在安装前测试一下,并不会真正的将软件包安装到系统中</p><p>​    –nodeps:忽略依赖关系,为什么要有这个选项呢,最主要的是有时候软件包依赖会出现循环依赖,就是包1依赖包2包2依赖包3而包3又依赖包1</p><p>​    –replacepkgs:重新安装,当不小心删除了这个软件中的某个文件后,可以使用这个选项再重新安装</p><p>​    –replacefiles:当安装某个程序包时,程序包中的某个文件已经存在系统上的时候,直接安装软件包就会报错,可以使用这个选项,强制覆盖已有的文件</p><p>​    –nosignature:不检查软件包的来源合法性,在centos安装光盘中会有一个RPM-GPG-KEY-CentOS-6文件,可以将这个文件使用–import导入到系统中,然后在每个rpm包中都附加了加密信息,可以使用导入的那个文件中的密文和软件包中的密文进行比对,</p><p>​    –noscript:不执行软件包自带的脚本</p><p>​        %pre:        安装前的脚本        –nopre</p><p>​        %post:        安装后的脚本        –nopost</p><p>​        %preun:        卸载前的脚本        –nopreun</p><p>​        %postun:    卸载后的脚本        –postun</p><p>​    –oldpackage:降级操作</p><p>​    –force:强制安装,只能用于安装卸载</p><p><strong>升级:</strong><br>    rpm {-U|–upgrade} [install-options] PACKAGE_FILE …<br>    rpm {-F|–freshen} [install-options] PACKAGE_FILE …</p><p>​        -U:也就是upgrade:如果这个软件包存在,就升级这个软件包,如果不存在就将这个软包包安装到系统中</p><p>​        -F:也就freshen:这个就是只升级,如果软件包不存在,也不进行任何操作</p><p>查询:rpm {-q|–query} [select-options][query-options]</p><p>​    -q package_name:查看软件包是否被安装,以下的查询选项都需要加-q,这个也是比较重要的一些内容</p><p>​            -l:列出安装包中的文件</p><p>​            -a:列出所有已安装的包</p><p>​            -f:查看某一个文件属于哪个软件包</p><p>​            -d:查询软件包的文档文件</p><p>​            -p:指定对安装包文件进行查询</p><p>​            -c:查询安装包都有哪些配置文件</p><p>​            -i:查看安装包的元数据信息</p><p>​            -R:查询软件包的依赖关系</p><p>​            –changelog:查看软件包的更新日志,注意,是该软件包的,并不是源代码</p><p>​            –scripts:查询软件包自带的脚本</p><p>​    <strong>注意</strong>:每使用rpm安装,升级,卸载一个软件包的时候,rpm都会记录在自己的数据中,数据库的位置在/var/lib/rpm/中,这样以上的这些查询都是通过这个数据库查询得到的,当然如果破坏了这个数据库的话,不光是查询,安装卸载等操作也无法进行,因为在安装前,rpm肯定是要去查一下这个软件包是否被安装,以及他的依赖包是否被安装,这些信息都是通过这个数据库进行查询的,如果破坏了,系统就会乱掉</p><p><strong>卸载</strong>:rpm {-e|–erase} [–allmatches][–justdb][–nodeps][–noscripts][–notriggers][–test] PACKAGE_NAME …<br>            –allmatches:卸载所有版本</p><p><strong>包校验</strong>: rpm {-V|–verify} [select-options][verify-options]<br>            -V:与数据库比对,查看哪些文件的属性发生了改变<br>                各段代表的含义:<br>                    S file Size differs<br>                    M Mode differs (includes permissions and file type)<br>                    5 digest (formerly MD5 sum) differs<br>                    D Device major/minor number mismatch<br>                    L readLink(2) path mismatch<br>                    U User ownership differs<br>                    G Group ownership differs<br>                    T mTime differs<br>                    P caPabilities differ</p><p><strong>数据库重建:</strong>注意这个重建可能只是部分数据破坏了可以重建,当所有数据库文件都被删除后,这实际上是没有任何意义的<br>            rpm {–initdb|–rebuilddb}<br>                initdb:初始化<br>                    如果事不存在数据库,则新建之,否则不执行任何操作<br>                rebuilddb:重建<br>                    无论当前存在与否,直接重新创建数据库</p><h3 id="YUM包管理器"><a href="#YUM包管理器" class="headerlink" title="YUM包管理器"></a>YUM包管理器</h3><p>当你使用以上的命令去安装了一些软件包的时候,你可能已经开始吐槽了,因为依赖关系实在是太让人头疼了,接下来我们就来介绍一下可以解决依赖关系的包管理器yum,全称yellow dog</p><p>​    yum是用Python实现的一个rpm的前端程序,也就是说其底层仍然调用的是rpm来安装软件,yum是一个c/s架构的软件也就是说需要一个服务端也称为软件仓库,本地的yum命令是yum的客户端,主要的实现方式是,在yum服务器上的repodata目录中存放了所有软件包的元数据信息,包括各个软件包之间的依赖关系,在客户端连接服务器的时候,发现本地缓存没有软件包的元数据信息,首先会将元数据信息同步到本地,然后会分析出需要安装的软件包的依赖关系,然后从服务器将这些软件包下载到本地的缓存目录中并安装之,安装成功后再将下载的软件包删除</p><p>接下来就介绍一下怎样去配置yum,yum有两个配置文件,一个主配置文件,另一个是软件仓库配置文件</p><p>​    主配置文件:/etc/yum.conf:以下是主配置文件的一些选项</p><p>​        [main]    这个是配置段名,main是必须的</p><p>​        cachedir=/path/to/cahcedir:缓存文件的目录</p><p>​        keepcache={0|1}:安装软件完成后,软件包是否删除,</p><p>​        debuglevel=2:设置debug等级</p><p>​        logfile=/path/to/log:日志目录的位置</p><p>​        installonly_limit:一次yum命令可以同时安装几个软件包,注意这个指的是单个yum进程的,也就是说,如果现在运行着一个yum命令,是不允许再运行第二个的,必须等第一个执行完成后才可以执行第二个</p><p>​    仓库配置文件/etc/yum.repos.d/*.repo:在yum.repos.d目录下只要是以.repo结尾的就认为是一个配置文件</p><p>​            [name] :中括号括起来的名字,可以随意写</p><p>​            name=REPO_NAME:这个是你个人为这个yum仓库起的名字,在使用是会显示</p><p>​            baseurl=url:软件仓库的url:支持的协议有http,https,ftp,file</p><p>​            gpgcheck={0|1}:是否检查软件包签名,完整性</p><p>​            gpgkey=/key/file/url:指定检查包完整性的key的位置</p><p>​            enable={1|0}是否启用这个仓库</p><p>​            mirrorlist=/path/to/url_list:将多个源的url写入一个文件,这里指向这个文件的位置</p><p>​            failovermethod={roundrobin|priority}:多个源地址时的使用顺序</p><p>​                roundroid:随机挑选,默认</p><p>​                priority:按顺序访问</p><p>​            cost=n:这个软件仓库的使用优先级</p><p>​    下面还有一些变量可以在url中使用,方便一个配置文件可以在多个系统中使用</p><p>​            $basharch:CPU基础平台比如说x86_64</p><p>​            $arch:平台</p><p>​            $releasever:服务器操作系统主版本号</p><p>​            \$YUM0-\$YUM9:为使用者分配的自定义变量,可以对这些变量进行赋值,然后使用</p><p><strong>yum命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">repolist [all|enabled|disabled]:查看当前的软件仓库列表列表,默认为已启用的可以使用</span><br><span class="line">repolist all显示所有,repolist disabled查看已禁用的</span><br><span class="line">clean [all|pacages|metadata|expr]:清理缓存</span><br><span class="line">install:</span><br><span class="line">reinstall:重新安装</span><br><span class="line">list [all|glob|package|installed]:最后一列带@的表示已经安装的@后面的内容表示从哪个仓库安装的,anaconda表示装系统时安装的</span><br><span class="line">update:升级</span><br><span class="line">downgrade:降级</span><br><span class="line">check-update:检查升级</span><br><span class="line">remove:卸载包</span><br><span class="line">info:显示软件包信息</span><br><span class="line">provides:查看特性属于哪个包</span><br><span class="line">makecahce:生成缓存</span><br><span class="line">search:搜索</span><br><span class="line">deplist:显示软件包依赖关系</span><br><span class="line"><span class="built_in">history</span>:</span><br><span class="line">list:列出历史</span><br><span class="line">undo id:撤销某一次操作</span><br><span class="line">redo id:重新执行一次某一个操作</span><br><span class="line">包组管理:</span><br><span class="line">yum groupinstall</span><br><span class="line">其他选项:</span><br><span class="line">-y:自动回答为y</span><br><span class="line">-q:静默模式,不能和-y合并,必须分开写</span><br><span class="line">--enablerepo=<span class="string">"repoid"</span>:临时启用</span><br><span class="line">--disablerepo=<span class="string">"repoid"</span>:临时禁用</span><br><span class="line">yum-config-manager:生成repo文件</span><br><span class="line">--add-repo=/url/path</span><br><span class="line">--<span class="built_in">disable</span> <span class="string">'仓库名'</span></span><br><span class="line">--<span class="built_in">enable</span> <span class="string">'仓库名'</span></span><br></pre></td></tr></table></figure><p>以上就是yum的安装方式,它可以解决软件包的依赖关系,当然以上两种操作方式有一个共同的缺点,就是软件安装的可定制性太差,甚至我们连安装路径的选择权利都没有,这不太符合Linux的风格,众所周知,Linux最大的亮点就是来源,所以我们可以下载到软件的源码包,这样我们就可以自己定制安装了,下面就开始介绍一下</p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>​    如果一个文件一个文件的去编译的话,那肯定得死,因此,虽说是源码安装,其实也提供了很多工具,将代码组织好按用户给定的选项进行安装,需要编译安装,首先肯定需要编译器,大多数Linux下的软件都是用c/c++编写的,因此在编译前我们得先把gcc安装好,当然了源代码也是要下载的,可以到软件的官方站点下载,下载下来一般都是压缩包,解压之后进入到源代码的目录,开始操作,下面就说一下编译的步骤,</p><p>​    1.在源码目录的根目录下执行./configure,这是一个脚本,是通过一些其他工具生成的,主要是检查系统当前环境,是否满足该软件的编译安装,这个脚本还可以通过选项来指定要启用或者禁用的特性,以及各种文件的安装路径,常用的有–prefix=/path/to/install_path,指定安装路径,–sysconfdir=/path/to/conf_dir,指定配置文件目录,另外可以使用–with-something=/path/to/some_dir,指定软件依赖其他软件的安装位置,这个依赖软件的位置一般是也是编译安装的如果不指定,它会从系统的PATH变量中找需要依赖的软件,当然如果找不到肯定会报错的,还有–enable,–disable来启用或者禁用软件特性,–help当然就是获取帮助啦,在help中显示的–enable对应的特性是软件编译时默认没有启用的,–disable对应的是软件编译时默认会启用的,这configure脚本会通过源码中的一个模板文件Makefile.in最终生成一个Makefile文件,当然这个文件就记录了软件编译时的一些信息,比如启用禁用的特性,文件路径等等</p><p>​    2.这一步就比较简单了,直接执行make命令就好了,make命令会通过Makefile文件对源码进行编译,这里有一个选项-j这个可以指定编译时使用的CPU数量来提高编译速度,当然如果编译出错或者需要重新编译时需要将之前编译的文件清理,可以使用make clean命令</p><p>​    3.这一步也是比较简单的,直接执行make install命令就可以了,这一步主要的作用就是将编译好的二进制文件,配置文件拷贝到用户指定的目录中去</p><p>​    以上就是软件包的编译大概过程,当然如果第一次编译可能会遇到各种各样的报错,大部分应该都会在执行./configure脚本时,认真看返回的报错信息,一般情况下都是缺少某些依赖包,可以根据报错中的软件包的名称安装其devel包来进行安装,也就是pack_name-devel</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    在Windows中装软件是特别轻松的事情,基本上下载一个exe的程序,然后双击,下一步就可以成功了,那么面对纯命令行接口的Linux,我们想装一个程序的话就需要使用相应的命令了,利用vim编辑文件都那么容易,装个软件包肯定不在话下,这篇文章主要总结一下Linux下程序包管理相关工具使用,以及相关的原理&lt;br&gt;
    
    </summary>
    
      <category term="Linux基础" scheme="http://smartyhero.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="程序包" scheme="http://smartyhero.com/tags/%E7%A8%8B%E5%BA%8F%E5%8C%85/"/>
    
      <category term="yum" scheme="http://smartyhero.com/tags/yum/"/>
    
      <category term="rpm" scheme="http://smartyhero.com/tags/rpm/"/>
    
  </entry>
  
  <entry>
    <title>记一次实验环境被黑</title>
    <link href="http://smartyhero.com/2018/05/17/hacked/"/>
    <id>http://smartyhero.com/2018/05/17/hacked/</id>
    <published>2018-05-17T09:11:12.000Z</published>
    <updated>2018-05-17T10:46:22.631Z</updated>
    
    <content type="html"><![CDATA[<p>我遇见黑客了!!! 昨天下午,我的实验环境的centos6被人用弱密码登录了</p><a id="more"></a><p>事情的开始大概是这样的,在要上最后一节课的时候,我发现我远程登录的centos6掉线了,打开虚拟机发现,居然关机了,在我的记忆中我是没有执行关机操作的,再去看我SecureCRT,这个操作并不是用我的电脑操作的,此时我忽然意识到,有人一定是利用了我的弱密码登录了我的系统,然后执行了什么,</p><p>此时我重新启动了系统,然而立即他自动又关闭了,可能是改了我的inittab文件,于是再次尝试使用启动系统进入单用户模式,但是貌似还不行,依然在开机后会自动关机,这就有点奇怪了,之后又改了grub的内核启动参数,只留下了内核文件和root路径,这次出现登录界面了,于是登录,输入密码回车后立马又关机了,这就有点无奈了,只能使用光盘启动了,</p><p>启动后将根切到我到磁盘,首先查看了我的inittab文件,发现并没有被修改,现在的情况就有点复杂了,他可能在我的系统启动时的任意一个文件中加入关机命令,我总不能一个文件一个文件一行一行的找吧,于是想到了一件事</p><p>如果对方是一个经验不是特别足的人,他修改了文件应该想不到去该文件的修改时间,于是用find指定mtime为1天之内的文件,开始查找,好像有点尿,搜出来一堆文件太多了,于是就一个目录一个目录的排除,首先搜了etc目录,没想到,第一次就成功了,成功的发现在/etc/profile.d/目录下有一个a.sh的脚本,这个文件肯定不是我建的,系统也不会用这么水的名字,果断用vi打开这个文件,我靠:</p><p><img src="/images/a_sh.png" alt=""></p><p>当时将这个脚本移动到了我的home目录下,然后重启系统,没有任何毛病的进入了系统,本想这下可以了吧,可能是老天保佑吧,原来有怀疑在计划任务动了手脚,导致每次开机后自动关机(其实这个想法也是挺蠢的)又看了一下计划任务,我靠,太损了,居然给我加了一条计划任务20:35的时候执行rm -rf /*,简直了,好歹都是一个班的,虽然可能连名都叫不上来,但这也有点损了吧,仔细想想,无论在做什么事上还是说话上我都应该没有得罪过谁吧,而且我平时都不怎么说话的,</p><p>看到这一步,有点小慌,他会不会还做了别的手脚,于是查看了at任务的列表,是空的,又想到了历史命令列表,然后输入了history命令:下面是这家伙执行的命令:</p><p><img src="/images/history.png" alt=""></p><p>确实添加了计划任务还有脚本,看来水平也一般嘛,历史记录都没有清理,到这里莫名还有点失望,这么容易就被我找到了,然后又用last查看了一下历史登录列表,现在看不见了,下面的图片是secure日志中的,</p><p><img src="/images/last.png" alt=""></p><p>大概就是这一条,ip还是给丫盖上吧,虽然只是内网的,而且现在应该也不用了,登录记录都被找到了,而且登录了两次,可能一直有一个疑问,为什么我的系统会关机呢,这可能还得感谢这位入侵我的同志呢,从之前的last命令来看,他登录了两次,第一次应该是上来执行了那些命令,然后就退出了,过了一会,可能又想到了别的破坏的点子,准备再次登录,结果登录的时候肯定会触发a.sh脚本,然后我的系统就关机了.</p><p>到这里,还没有完,这位同志不过登录了我的系统,还登录了离我不远的另外一位同学的系统,可能是从我这里长了经验,那位同学的应该并没有a.sh脚本,只添加了计划任务,晚上快下自习的时候只听他吭哧吭哧的修复系统,然后我还开玩笑说,你的密码不会也是123456吧,不会也被人定了计划任务删根了吧,当时他还不相信呢,折腾半天恢复不了了,用光盘引导后,看了一下根文件系统下,几乎没什么文件了,不过好像root目录还没有删干净,历史记录里还留了那个家伙执行的命令,居然还输入了f**k,</p><p>平淡枯燥的培训生活中,我好像还得感谢一下这位英雄,还给我增添了几分色彩,其实还是挺想不通这位仁兄的动机的,为了满足一下自己的虚荣心?秀一下自己的技术?想不通想不通,真的想不通,</p><p>最后还是要总结一波,昨天也是属于险中得胜呀,要是没有他的a.sh脚本,可能我开机后不会这么仔细的去检查的,密码要尽量设的复杂一点,其实和妈妈的唠叨是一样的,虽然很重要,但是往往会被忽略,对于这次事件的防护其实有多种,限制失败登录的次数,使用密钥方式登录系统,改默认端口等等等等,当然,安全只是相对的,今天就总结到这里</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我遇见黑客了!!! 昨天下午,我的实验环境的centos6被人用弱密码登录了&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://smartyhero.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="安全" scheme="http://smartyhero.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="弱口令" scheme="http://smartyhero.com/tags/%E5%BC%B1%E5%8F%A3%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>RAID&amp;LVM</title>
    <link href="http://smartyhero.com/2018/05/13/RAID-LVM/"/>
    <id>http://smartyhero.com/2018/05/13/RAID-LVM/</id>
    <published>2018-05-13T11:14:00.000Z</published>
    <updated>2018-05-13T13:45:29.784Z</updated>
    
    <content type="html"><![CDATA[<p>对raid级别进行介绍,mdadm工具,逻辑卷及其管理工具<br><a id="more"></a></p><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a><strong>简介</strong>:</h4><blockquote><p>中文名称叫做廉价的磁盘冗余阵列,使用多块硬盘组合工作,用来提高读写的性能以及磁盘的高可用性,通过将数据分成若干个chunk,根据不同的级别做相应的处理,有两种实现方式,一种是通过软件模拟,在Linux中可以使用mdadm这个工具进行模拟,这种方式的效果不是特别好,首先性能肯定不行,而且本人的测试过程中感觉不是特别好用,因此不建议在生产环境中使用,另外一种就是在生产环境中使用的,通过硬件实现的,最初的时候需要单独购买raid卡,才能使服务器支持,现在大多数的主板中都直接支持,需要在bios中做相应的设置就可以了,</p></blockquote><h4 id="RAID级别"><a href="#RAID级别" class="headerlink" title="RAID级别:"></a><strong>RAID级别</strong>:</h4><p>raid不同的级别定义了不同的工作方式,下面依次做介绍</p><p><strong>RAID0</strong>:条带集,将文件根据定义好的chunk切割为若干块,然后逐块将chunk存入不同的磁盘中,如下图所示:</p><p><img src="/images/raid0.png" alt=""></p><p><strong>RAID1</strong>:就是做镜像,就和备份一样,虽然和备份一样,但是却不可以当备份来用,因为删除一个文件后,两边的文件都会被删除</p><p><img src="/images/raid1.png" alt=""></p><p><strong>RAID4:</strong> 为了解决RAID0的可用性和RAID1的磁盘利用率低的问题,RAID4使用一块磁盘来存放另外两块硬盘的数据校验,且可以利用该校验位与其他的一块硬盘上的chunk来计算出另外一块磁盘上的chunk,这样就保证了如果有一块损坏,数据还可以正常使用,但是这种方式有一个问题就是存放校验位的磁盘故障率特别高,因此现在基本不用了</p><p><img src="/images/raid4.png" alt=""></p><p><strong>RAID5:</strong> 主要是解决了RAID4中校验位盘容易损坏的问题,它是将校验位依次存于每一块硬盘中,这样就解决了RAID4中的问题</p><p><img src="/images/raid5.png" alt=""></p><p><strong>RAID6</strong>:这是豪华版的RAID5,它每次用两块硬盘来存储校验位,这样可用性又提高了不少</p><p><img src="/images/raid6.png" alt=""></p><p>以下,用这个表格来列出各个级别的对比:</p><table><thead><tr><th>级别</th><th>名称</th><th>磁盘利用率</th><th>硬盘数</th><th>容错能力</th></tr></thead><tbody><tr><td>0</td><td>条带集</td><td>100%</td><td>最少2块</td><td>无</td></tr><tr><td>1</td><td>镜像</td><td>50%</td><td>最少2块</td><td>有</td></tr><tr><td>4</td><td>带有容错的条带集</td><td>(n-1)/n</td><td>最少3块</td><td>有</td></tr><tr><td>5</td><td>带有容错的条带集</td><td>(n-1)/n</td><td>最少3块</td><td>有</td></tr><tr><td>6</td><td>带有容错的条带集</td><td>(n-2)/n</td><td>最少4块</td><td>有</td></tr></tbody></table><p>以上是单个级别的一些介绍,当然还可以做raid组合,比如说RAID10,RAID01,可以先做几个个raid1,然后再将这几个raid1组合成raid0</p><h4 id="软RAID管理工具mdadm"><a href="#软RAID管理工具mdadm" class="headerlink" title="软RAID管理工具mdadm"></a>软RAID管理工具mdadm</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mdadm:</span></span><br><span class="line">-C /dev/md[0-9]:创建</span><br><span class="line">-l level:指定RAID级别</span><br><span class="line">-c size:指定chunk大小</span><br><span class="line">-n:指定磁盘个数</span><br><span class="line">-x:指定备用硬盘的个数</span><br><span class="line">-D:查看设备</span><br><span class="line">-f /dev/DEVICE:模拟损坏的硬盘</span><br><span class="line">-r:将某个设备从RAID中移出</span><br><span class="line">-a:向RAID中添加</span><br><span class="line">-Ds:显示RAID元数据信息</span><br><span class="line">-S /dev/md[0-9]:停用RAID设备,停用之前必须先取消设备挂载</span><br><span class="line">-G:增加设备</span><br><span class="line">--zero-superblock:清除分区中的RAID残留信息,应该在删除分区前清理</span><br><span class="line">/etc/mdadm.conf:配置文件,存放的是RAID设备的元数据,当停用RAID之后再启用必须有配置文件,否则无法启动</span><br><span class="line">/proc/mdstat:raid信息</span><br></pre></td></tr></table></figure><h2 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h2><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介:"></a>简介:</h4><blockquote><p>相对于RAID,LVM是纯在软件环境下实现的,主要的工作模式是,将若干个磁盘或者分区声明为物理卷,然后将这些物理卷再组织成卷组,这个卷组就相当于是一块硬盘,然后再将卷组分出多块逻辑卷,然后进行分区使用,逻辑卷最大的优势在于他可以动态扩容和做快照,由于其抽象出了好多层,因此如果误删除了数据,在恢复上可能会有一定的困难,因此LVM在一些企业中还是没有被采用的,以下这张图片清晰的描述了逻辑卷和物理硬盘之间的关系</p></blockquote><p><img src="/images/lvm.png" alt=""></p><p>因此逻辑卷的创建也是比较繁琐的,在使用时系统提供了以pv,vg,lv开头的若干个工具,分别来对物理卷,卷组,逻辑卷进行管理,以下对常用到的命令进行说明:</p><h4 id="lvm管理工具"><a href="#lvm管理工具" class="headerlink" title="lvm管理工具"></a>lvm管理工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/DEVICE ...:将分区创建为物理卷</span><br><span class="line">pvmove /dev/DEVICE:将物理卷中的空间移动到其他地方</span><br><span class="line">pvremove /dev/DEVICE:移出某个物理卷</span><br><span class="line"></span><br><span class="line">vgcreate vg_name /dev/DEVICE ...:将物理卷加入卷组</span><br><span class="line">-s:指定PE大小,会以PE为单位分配给逻辑卷</span><br><span class="line">vgextend vg_name /dev/DEVICE ... :扩展卷组</span><br><span class="line">vgreduce vg_name  /dev/DEVICE:把某个物理卷移出卷组</span><br><span class="line">vgrename old_name new_name:为卷组改名</span><br><span class="line">vgchange -an vg_name:禁用卷组</span><br><span class="line">-ay:激活卷组</span><br><span class="line">vgexport vg_name:将卷组变成导出状态</span><br><span class="line">vgimport:导入卷组</span><br><span class="line"></span><br><span class="line">lvcreate [OPTIONS]... vg_name:创建逻辑卷</span><br><span class="line">-n:指定逻辑卷名称</span><br><span class="line">-L:指定大小,以容量为单位,也并非实际大小,而是最接近的PE个数的大小</span><br><span class="line">-l:指定大小,以PE为单位,k可以指定相对VG,FREE,ORIGIN的百分比</span><br><span class="line">-s:创建快照,通过快照恢复之后的逻辑卷是不可以再次创建快照的</span><br><span class="line">-p r:指定属性为只读</span><br><span class="line">lvextend [OPTION]... vg_name:扩展逻辑卷空间,扩展之后应该使用resize2fs或者xfs_</span><br><span class="line">-l [+]size:增加到size,+size:增加size 按&#123;VG|LV|PVS|FREE|ORIGIN&#125;的百分比</span><br><span class="line">-L [+]size:扩展大小 按大小[bBsSkKmMgGtTpPeE]</span><br><span class="line">-r:扩展的同时同步文件系统</span><br><span class="line">lvrename /old/dev/path /new/dev/path:修改逻辑卷的名称,注意,要写lv设备的路径,先写原名再写新名</span><br><span class="line">ext系列文件系统可以缩小,xfs不可以</span><br></pre></td></tr></table></figure><h4 id="快照"><a href="#快照" class="headerlink" title="快照:"></a>快照:</h4><blockquote><p>​    保存了逻辑卷的某个时间点的状态,创建最初只是创建了一个空的逻辑卷,因此创建速度非常快,之后当有文件被修改时,先将被修改的那个文件复制到快照逻辑卷中,然后再修改,如果没有修改过的,虽然在快照中也能看见,但其实读的是原来逻辑卷中的内容,就像进程的写时复制一样,虽然这样很好,但是不太建议直接用快照来做备份,因为快照和原来的数据都存放在同一个设备上,这个设备一旦坏了,那快照也是白玩,因此正确玩法是先做快照,将快照中的内容保存到其他地方,然后再将快照删除,快照的创建和普通逻辑卷创建一样,只不过需要加一个-s的参数</p></blockquote><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建:</span><br><span class="line"><span class="comment"># lvcreate -n lv_name_snapshot -s -L size -p r /dev/vg_name/lv_name</span></span><br><span class="line">恢复:</span><br><span class="line"><span class="comment"># lvconvert --merge /dev/vg_name/lv_snopshot:还原快照,还原成功后快照被自动删除</span></span><br></pre></td></tr></table></figure><h4 id="逻辑卷缩减-迁移的操作"><a href="#逻辑卷缩减-迁移的操作" class="headerlink" title="逻辑卷缩减,迁移的操作"></a>逻辑卷缩减,迁移的操作</h4><pre><code>缩减逻辑卷的步骤:    1.卸载需要缩减的逻辑卷    2.检测修复文件系统fsck -f /dev/DEVICE    3.缩减文件系统:resize2fs /dev/DEVICE size    4.lvreduce -L SIZE /dev/DEVICE    5.缩减完成,重新挂载    注意:xfs文件系统最好不要做缩减迁移逻辑卷    1.将数据迁移到最少的硬盘上pvremove    2.将空物理卷从卷组中移除,vgreduce vg_name /dev/DEVICE    3.将空的物理卷变成普通硬盘或分区,pvremove /dev/DEVICE    4.禁用需要导出的卷组 vgchange -an vg_name    5.将需要迁移的硬盘变成导出状态vgexport vg_name    6.将硬盘插到其他的机器上,使用vgimport vg_name导入</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对raid级别进行介绍,mdadm工具,逻辑卷及其管理工具&lt;br&gt;
    
    </summary>
    
      <category term="Linux基础" scheme="http://smartyhero.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="linux,磁盘" scheme="http://smartyhero.com/tags/linux-%E7%A3%81%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>linux用户管理</title>
    <link href="http://smartyhero.com/2018/05/11/test/"/>
    <id>http://smartyhero.com/2018/05/11/test/</id>
    <published>2018-05-11T11:15:00.000Z</published>
    <updated>2018-05-23T04:51:57.112Z</updated>
    
    <content type="html"><![CDATA[<p>Linux用户管理及一些操作,包括个人的理解<br><a id="more"></a></p><h4 id="Linux创建用户的过程"><a href="#Linux创建用户的过程" class="headerlink" title="Linux创建用户的过程"></a>Linux创建用户的过程</h4><p><u><strong>以下内容为仅使用useradd user_name创建用户时的大概过程,这里写的先后顺序不代表系统在执行时的先后顺序,当然以下的这段内容其实也是是本人根据实际操作通过系统返回的效果得出的,也并不代表系统就是这样执行的:</strong></u></p><ol><li><p>读取/etc/default/useradd文件,获取用户的家目录位置,使用的shell,以及是否进行用户邮箱的创建等信息,读取/etc/login.defs文件,获取用户的uid范围gid范围,以及用户的密码有效期,用户有效期的值等    </p></li><li><p>根据以上两个文件创建在/etc/group文件创建一条记录,该记录是组信息记录,(组名:组密码:组id:组成员)大致内容为组名,组密码,组id,组成员(不包括将此组作为主组的用户),组名和用户名相同,如果该组已经存在则创建失败,密码为x表示密码没有存在这个文件中,而是被存在了/etc/gshadow文件中,即其他用户无法将此组切换为临时主组,组id,正常情况下会取上一个最大的id然后加1作为该组的id,组成员默认为空</p></li><li><p>在/etc/gshadow中创建一条记录,(组名:组密码:组管理员:组成员)大概内容为组名,组密码,组管理员,组成员,组密码格式为使用三个\$符号分割三组内容,第一个\$后表示的是加密的类型用一个数字表示,第二个\$后面是密码加密时用的盐即随机数,加了这个盐之后即使两个用户的密码相同那么最后得到的加密字符串也是不同的,然后\$后面是密码加密后的字符串!即用户无法通过newgrp命令临时切换该组为主组,组管理员默认为空可以使用gpasswd的-A选项指定管理员员,组成默认也为空,组成员和/etc/group中的组成员内容相同,添加组成员可以使用gpasswd命令的-a选项添加,-d选项删除,当然必须有操作权限,即组管理员和root</p></li><li><p>在/etc/passwd中创建一条记录,(用户:用户密码:uid:gid:描述信息:家目录:默认shell)该记录是用户信息记录,大致内容为,用户名,密码,uid,gid,描述信息,家目录,默认shell,用户名即创建用户时指定的用户名,passwd为x表示密码存放在了/etc/shadow/这个文件中,由于/etc/passwd文件普通用户也可以读取到,所以特将密码存到另外的文件中当然是可以用pwconv和pwuncounv命令改变密码存位置的 uid为系统根据当前用户id分配情况分配一个id,gid为步骤3中创建组信息时的gid,描述信息默认为空,可以使用chfn命令写入描述信息,家目录为从/etc/default/useradd中读取的家目录的路径然后在其下创建一个和user_name同名的目录,默认shell也是从/etc/default/useradd中读取的,默认为/bin/bash</p></li><li><p>在/etc/shadow中创建一条记录,(用户名:密码:上一次修改密码的时间:修改密码后几天内不允许再次修改:密码有效期:密码过期前提下的天数:宽限期:用户有效期:保留字段)该记录主要存放了,用户名,密码,上一次修改密码的时间,该时间的格式为从1970年1月1日到修改日期所经过的天数,修改密码后几天内不可以修改密码,密码的有效期,密码过期前的提醒的天数,宽限的期限即密码过期后还可以登录的天数,用户的有效期即过了这个时间后用户就会被锁定,以上几个有效期相关的时间可以使用chage修改保留字段可能以后的系统会添加其他功能就可以使用这个字段了</p></li><li><p>创建家目录,并且将/etc/skel/中的文件拷贝到用户的家目录下,这些文件主要的作用是初始化登录环境,设置某些系统变量的</p></li><li><p>在邮箱目录中创建邮箱文件文件名和用户名同名</p></li></ol><p>以上四个文件(passwd,group,shadow,gshadow)的格式为:分割的字符串</p><p>如果家目录不存在,则登录系统后的当前目录是/</p><p>系统必须有0id的用户</p><h4 id="用户-组介绍"><a href="#用户-组介绍" class="headerlink" title="用户,组介绍"></a>用户,组介绍</h4><p><strong>用户(user)</strong></p><p>管理员:    root,0</p><p>通用户:    1-65535<br>    系统用户:1-499,1-999(CentOS7.x),主要是对一些服务，应用等使用的</p><p><strong>组(group)</strong></p><p>管理员组 root,0<br>普通组:<br>    系统组:1-499,1-999(CentOS7.x)<br>    普通组:500+,1000+(CentOS7.x)<br>Linux默认创建一个用户就会创建一个相同名称的组,且这个用户默认属于这个组<br>进程所能够访问的文件由创建进程的用户权限决定<br>用户和组可以是多对多的关系</p><p><strong>Linux组的类别</strong></p><p>主要组(primary group)<br>        用户至少属于一个组,必须有一个主组<br>    附加组(supplementary group)<br>        一个用户可以属于0个或多个附加组</p><h4 id="用户和组的主要配置文件"><a href="#用户和组的主要配置文件" class="headerlink" title="用户和组的主要配置文件"></a>用户和组的主要配置文件</h4><ul><li><strong>/etc/passwd</strong>:(用户信息)</li></ul><p>​        name:password:UID:GID:GECOS:directory:shell<br>        GECOS:描述字段</p><ul><li><p><strong>/etc/group</strong>:(组信息)</p><p>​    group_name</p><pre><code>password:                        普通用户也可以自己把自己加到某个组中,需要使用这个密码GIDuser_list:                        附加组是该组的user_name</code></pre></li><li><p><strong>/etc/shadow</strong>:(用户口令)</p><p>​    login name:                        用户名</p><pre><code>encrypted password:                !!表示账户锁定,新建的账号不能登录是锁定状态    密码的格式:$加密算法$盐$加密后的字符串    加密算法:1:md5,6:sha512    修改加密算法    </code></pre><p>​            # authconfig –passalgo={sha512|…} –update</p><p>​    date of last password change:</p><pre><code>上一次修改密码的时间,格式为距离1970年到现在的天数,如果值为0系统在下次登录时提醒你改密码</code></pre><p>​    minimum password age:            最短的密码生命期,最短口令有效期,单位为天,0为随时可以改</p><pre><code>maximum password age:            口令有效期password warning period:            口令过期前提示时间password inactivity period:        宽限期,过期后的时限,过期之后再过了这几天就被系统锁定了account expiration date:            账号的有效期reserved field:                    保留字段</code></pre></li><li><p><strong>/etc/gshadow</strong>:(组口令)</p><p> group name                         组名<br> encrypted password                加密后的密码<br> administrators:                    组管理员<br> members:                        组成员</p></li></ul><h4 id="用户和组的管理命令"><a href="#用户和组的管理命令" class="headerlink" title="用户和组的管理命令"></a>用户和组的管理命令</h4><ul><li><p><strong>用户管理</strong></p><p># useradd:(添加用户)</p><p>| 选项 | 作用                                                         |<br>| :— | ———————————————————— |<br>| -o   | 强制创建已存在的id的用户,使用这种用户登录系统时虽然两个账号都能登录但是系统在登录后会以在passwd文件中靠前的用户信息作为用户等信息 |<br>| -u   | 指定uid                                                      |<br>| -g   | 指定gid或者组名                                              |<br>| -G   | 指定附加组id                                                 |<br>| -d   | 指定家目录                                                   |<br>| -s   | 指定shell,一般服务所用的账号都应该将shell设置为/sbin/nologin即不允许该用户登录系统 |<br>| -r   | 创建系统用户                                                 |<br>| -m   | 创建系统用户的时候创建家目录                                 |<br>| -M   | 不创建家目录                                                 |<br>| -D   | 此选项不是在创建用户的时候使用的,主要的作用是使用该命令去查看,修改配置文件/etc/default/useradd |<br>| -N   | 不创建该用户名相同的组为主组而将其加入到配置文件指定的组中默认是user组 |</p></li></ul><p># usermod:修改用户</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-u</td><td>更改uid</td></tr><tr><td>-g</td><td>指定新的主组</td></tr><tr><td>-G</td><td>指定附加组,默认是覆盖行为,如果要追加要使用-a选项””为将附加组设为空,或者将该用户设为附加组,这样覆盖了其他所有的附加组</td></tr><tr><td>-l</td><td>修改组名,new_name old_name</td></tr><tr><td>-d</td><td>更换家目录,需要创建新的家目录并且移动文件时需要-m选项</td></tr><tr><td>-L</td><td>锁定用户</td></tr><tr><td>-U</td><td>解锁用户</td></tr><tr><td>-e</td><td>指定过期日期</td></tr><tr><td>-f</td><td>设置宽限期</td></tr></tbody></table><p># userdel:(删除用户的同同时也会尝试去删除他的主组)</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-r</td><td>删除家目录以及邮箱文件</td></tr></tbody></table><p># passwd:修改用户密码</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-e</td><td>立即过期用户口令,且用户再次登录时必须设置一个比较复杂的密码</td></tr></tbody></table><ul><li><p><strong>组管理:</strong></p><pre><code>\# groupadd (添加组)-g:指定gid-r:创建系统组</code></pre><p>  # groupmod:</p><pre><code>-n new_name old_name:改名-g:指定新的id</code></pre><p>  # groupdel:如果某个组是某个账号的主组,那这个组在账号存在的情况下不能删除<br>  # gpasswd:</p><pre><code>-a user 将某个账号加入某个组-d 从该组删除某个账号-A 设置组管理员</code></pre></li></ul><h4 id="其他和用户-组相关的命令"><a href="#其他和用户-组相关的命令" class="headerlink" title="其他和用户,组相关的命令"></a>其他和用户,组相关的命令</h4><p>​    # groupmems:允许组管理员管理其组成员,查看将该组设置为附加组的组成员<br>        -g:指定组名<br>        -l:列出组员列表<br>        -d:将指定用户踢出该组<br>        -a:为该组添加用户<br>        -p:清除该组中所有成员</p><pre><code># groups:查看账号属于哪个组,主组和附加组# chfn:为用户添加描述信息# finger:查看用户信息# chsh -s /bin/bash user_name:更用户的默认shell,不加用户为修改当前用户shell# newusers /path/to/user_list 批量创建用户# chpasswd &lt; /path/to/usre:pass_list:批量修改用户密码pass_list格式为user_name:password# chage 修改用户有效期相关信息,交互式修改各个参数    -d 0 user_name:立即过期用,且下次登录会强制用户改一个复杂度较高的密码</code></pre><p>​    # newgrp 临时切换当前用户的主组,可以使用exit命令退出,仍然使用之前的主组<br>    # authconfig –passalgo={sha512|…} –update 修改加密算法<br>    # getent passwd [user_name]:只显示某个user的信息,<br>    # su:切换用户<br>        -c:以某个用户身份执行命令<br>         完全切换<br>             # su - user_name<br>             # su - 直接切换到root用户,当然非root用户需要密码才可以切换<br>         不完全切换:<br>             # su user_name<br>         完全切换就和新用户登录一样,而不完全切换则不同,shell的某些变量还保存的是之前用户的信息<br>        而且目录也不会切换到当前用户的家目录<br>    # id:显示用户的id信息以及判断该用户是否存在<br>        -u:显示uid<br>        -g:显示gid<br>        -G:显示附加组的id<br>        -n:显示名称<br>    # vipw == vi /etc/passwd<br>    # vigr == vi /etc/group<br>        修改了文件后vipw,vigr可以使用相关选项同步其他文件<br>    # pwck     检查/etc/passwd,/etc/shadow配置文件<br>    # grpck 检查/etc/group,/etc/gshadow配置文件<br>    # pwconv:将密码存入shadow文件<br>    # pwunconv:将密码存入passwd文件<br>    # grpconv:将组密码存入gshadow文件<br>    # grpuncoun:将组密码存入group文件</p><h4 id="相关的其他配置文件"><a href="#相关的其他配置文件" class="headerlink" title="相关的其他配置文件"></a>相关的其他配置文件</h4><p>​    /etc/skel:创建用户时会将这个目录里的文件复制到用户的家目录中,创建用户时的家目录模板文件夹<br>    /etc/default/useradd:主要定义了用户家目录的位置,shell类型等<br>    /etc/login.defs:主要定义了用户的uid起始,已经账号,密码有效期等信息</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux用户管理及一些操作,包括个人的理解&lt;br&gt;
    
    </summary>
    
      <category term="Linux基础" scheme="http://smartyhero.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="linux" scheme="http://smartyhero.com/tags/linux/"/>
    
      <category term="用户" scheme="http://smartyhero.com/tags/%E7%94%A8%E6%88%B7/"/>
    
  </entry>
  
  <entry>
    <title>linux进程管理</title>
    <link href="http://smartyhero.com/2018/05/11/article-title/"/>
    <id>http://smartyhero.com/2018/05/11/article-title/</id>
    <published>2018-05-11T05:10:00.000Z</published>
    <updated>2018-05-23T04:51:37.645Z</updated>
    
    <content type="html"><![CDATA[<p>首先区分一下进程和程序的概念,程序是一种静态的,是一个文件或者是一组文件的集合,存储在硬盘中,当用户需要时用该程序时,利用操作系统的交互界面运行程序,此时程序会被载入内存,由操作系统为其分配内存空间,然后操作系统还会维护一段数据用于描述该程序的一些状态,就像文件的元数据一样,在Linux中操作系统会创建一个task_struct的数据结构用于存放这些,此时在内中的这些数据被称为是一个进程<br><a id="more"></a></p><h1 id="linux进程管理"><a href="#linux进程管理" class="headerlink" title="linux进程管理"></a>linux进程管理</h1><h3 id="一-进程相关概念"><a href="#一-进程相关概念" class="headerlink" title="一.进程相关概念"></a>一.进程相关概念</h3><h4 id="1-进程与程序的关系"><a href="#1-进程与程序的关系" class="headerlink" title="1.进程与程序的关系"></a>1.进程与程序的关系</h4><p>​    首先区分一下进程和程序的概念,程序是一种静态的,是一个文件或者是一组文件的集合,存储在硬盘中,当用户需要时用该程序时,利用操作系统的交互界面运行程序,此时程序会被载入内存,由操作系统为其分配内存空间,然后操作系统还会维护一段数据用于描述该程序的一些状态,就像文件的元数据一样,在Linux中操作系统会创建一个task_struct的数据结构用于存放这些,此时在内中的这些数据被称为是一个进程<br><!-- more --></p><h4 id="2-进程的创建"><a href="#2-进程的创建" class="headerlink" title="2.进程的创建"></a>2.进程的创建</h4><p>​    首先,进程是有父子关系的即每一个进程都是由另外的一个进程创建的,当然在操作系统启动的时候会创建其老祖进程,在CentOS6中该进程是init而在CentOS7中这个进程是systemd在Linux中创建进程主要使用了两个函数fork()和clone(),关于这两个函数这里不做具体阐述,因为我也不了解其内部机制,创建进程使用的是一种叫做写时复制(CoW)的机制来创建进程的,这种机制是比较节省资源的,在进程创建之初系统并不会真正的为其分配内存,而是与其父进程,即创建该进程的进程以只读的方式共享同一块内存,当子进程需要写入数据的时候操作系统才会复制一份父进程的内存空间到其他地方给子进程,这里就有点类似lvm中的快照了</p><h4 id="3-进程的状态"><a href="#3-进程的状态" class="headerlink" title="3.进程的状态"></a>3.进程的状态</h4><p>​    众所周知,虽然现在的操作系统同时可以运行多个程序,但是在同一个CPU上,某一个时间点上只有一个进程在运行,我们看到的多个进程同时运行其实是一个假象,CPU是通过时间片的方式来运行多个程序的,即某一个时间段运行一个进程下一个时间段运行另外一个进程,这个时间段是以毫秒为单位进行分配的,因此我们人类根本感觉不到他的切换,这里也就引出了一个问题,进程的状态切换,用下面这张图加以说明:</p><p>​    <img src="../imgs/process_state.png" alt=""></p><p>以上这张图中需要强调的是进程进入阻塞状态时,当io完成时不可以直接进入运行状态必须先进入就绪状态,等待系统为其分配时间片才能执行,当然上图中只是常见的一些状态的转换过程,还有其他的状态,比如有一个需要关注的状态将僵尸态或者叫孤儿进程,这个进程形成的原因是当某一个进程结束时没有能够正常的处理其子进程,导致子进程既没有被正常结束,也没有成为其他进程的子进程,导致这个进程没有父进程,这样这个进程不但不能正常执行而且还占用着内存资源</p><h4 id="4-进程优先级"><a href="#4-进程优先级" class="headerlink" title="4.进程优先级"></a>4.进程优先级</h4><p>​    在Linux操作系统采用的是抢占式的多任务,系统有n多个进程,有很多是特别主要的,有一些会次一点,这里就像我们现在的社会一样,进程是有优先级的,而且系统有那么多进程需要运行,当当前进程的CPU时间片到了之后决定下个时间片分给哪一个进程是一件很头疼的事,这样就为其分配一个优先级,当然如果决定下一个时间片分给谁的时候再去比对每一个进程的优先级,显然是一件特别浪费资源的事情,在Linux中系统的开发者也非常巧妙的处理了这个问题,那就是分配队列,将优先级相同的进程放到同一个队列中这个队列叫运行队列,这样下次切换进程的时候先决定执行哪一个优先级然后找到其队列然后直接执行队列中的第一个进程,时间片到了将这个进程放入另外的一个队列,该优先级的过期队列,等待优先级队列里的进程数为0的时候再将这个过期队列转换为运行队列,另外这个进程的优先级并不是一个绝对的概念,而是相对的CPU多去执行它,当然具体的决策过程这里不做阐述</p><h3 id="二-进程管理工具"><a href="#二-进程管理工具" class="headerlink" title="二.进程管理工具"></a>二.进程管理工具</h3><p>​    <strong>1.<em>ps</em></strong>这个ps可不是Photoshop而是process state,即进程状态,这个工具主要的作用就是查看系统中的进程及其一些属性信息,可能是由于历史的原因吧,这个工具有三种选项风格:UNIX风格,BSD风格,GNU风格,下面就对其选项进行说明,默认情况下只显示当前终端中的进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BSD风格:</span><br><span class="line">a:包含所有终端中运行的进程</span><br><span class="line">x:和终端无关的进程</span><br><span class="line">u:显示更详细的信息</span><br><span class="line">f:树状显示进程父子关系</span><br><span class="line">k/--sort 属性:对属性排序属性前加-表示倒叙</span><br><span class="line">o:只显示特定的属性,各个属性用逗号分隔,注意此选项不能和u共用</span><br><span class="line">L:显示支持的属性列表</span><br><span class="line">Z:显示SELinux相关</span><br><span class="line">UNIX选项:</span><br><span class="line">-e:显示所有进程</span><br><span class="line">-f:显示完整格式列表</span><br><span class="line">-F:比f更详细的</span><br><span class="line">-H:层级显示进程的父子关系</span><br><span class="line">-u:指定有效用户ID或名称</span><br><span class="line">-U:指定实际用户ID或名称</span><br><span class="line">-p:显示指定pid的进程</span><br><span class="line">-M:显示SELinux相关属性</span><br><span class="line">-C:指定程序的进程列表,注意,脚本中如果不加shebang头,进程中的命令就变成了bash,如果使用</span><br><span class="line">   bash script_name运行的程序,进程列表中显示的是bash script_name</span><br></pre></td></tr></table></figure><p>以下是一个示例:</p><p><img src="../imgs/ps-demo.png" alt=""></p><p>下面对上图中各列进行解释:</p><pre><code>PID:进程的PIDPPID:父进程IDTIME:该进程累计CPU时间片的总和TTY:程序运行在哪个终端上STAT:进程的状态    D:不可中断睡眠,通常在等待IO完成    R:运行或者可运行,在运行队列中    S:可中断睡眠,等待事件完成    X:已经执行结束的进程,不可能出现?    Z:僵尸进程,由于其父进程不负责任,父进程终止后子进程没有被同时终止,    或者没有重新为子进程找好父进程    &lt;:高优先级    N:低优先级    l:是多线程的    L:将页锁定在内存中,用户实时或者自定义IO    +:位于前台进程组中    s:子进程的发起者COMMAND:运行的程序%CPU:占用CPU的百分比%MEM:占用内存的百分比START:进程启动时间VSZ:操作系统允许使用的最大内存RSS:目前使用的内存EUSER:现在程序正在运行时使用的用户,可能该程序被设置了suid权限,RUSER:进程的发起者,和USER显示的一样,可以理解成RealUserETIME:进程启动了多长时间PSR:当前进程运行在哪个CPU上PRI:系统优先级反过来,priority优先级NICE:nice优先级-20-19RTPRIO:实时优先级</code></pre><p>​    <strong>2.<em>pgrep</em>:搜索进程,支持正则表达式</strong>,使用格式 pgrep [option] pattern</p><pre><code>-l:显示进程名称,比较简洁-t:显示进程pid-a:显示完整名称-P pid:显示某个父进程中的子进程    </code></pre><p>​    <strong>3.<em>pidof</em></strong>,显示某个进程对应的pid</p><p>​    <strong>4.<em>kill</em></strong>:这个命令主要是可以向进程发送信号,用法:kill [-SIGNAL] pid,SIGNAL是信号,是一个数字,下面对各数字及其含义做解释</p><blockquote><p>​            1/SIGHUB:让进程重读配置文件</p><p>​            2/SIGINT:相当于执行Ctrl+c</p><p>​            3/SIGQUIT:相当于Ctrl+\,退出</p><p>​            9/SIGKILL:强行杀死进程</p><p>​            15/SIGTERM:正常退出进程,默认是15</p><p>​            18/:继续运行信号</p><p>​            19/SIG:发送休眠信号</p></blockquote><p>和kill功能差不多的还有两个命令:killall和pkill,killall是给所有该进程名的进程发信号pkill可以使用扩展的正则表达式匹配相应的进程名</p><p>​    <strong>5.进程的前后台切换</strong>:</p><p>​        COMMAND &amp;:COMMAND是要执行的命令在其后面加上&amp;,这个命令就会在后台显示,但是其标准输出还会输出到屏幕上</p><p>​        Ctrl+z:将正在进行的程序进行休眠,并放入后台</p><p>​        fg job_id:将后台程序切换到前台并进行执行</p><p>​        bg job_id:将后台休眠程序激活仍然在后台执行</p><p>​        jobs:查看当前终端中运行的后台程序和后台休眠程序,在这里就可以查看到其job_id</p><p>​    4.并行执行多个命令:</p><p>​        1.在每个命令后都加上&amp;</p><p>​        2.(COMMAND1 &amp;);(COMMAND2 &amp;);(COMMAND3 &amp;);…</p><p>​        3.{ COMMAND1 &amp; COMMAND2 &amp; …}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先区分一下进程和程序的概念,程序是一种静态的,是一个文件或者是一组文件的集合,存储在硬盘中,当用户需要时用该程序时,利用操作系统的交互界面运行程序,此时程序会被载入内存,由操作系统为其分配内存空间,然后操作系统还会维护一段数据用于描述该程序的一些状态,就像文件的元数据一样,在Linux中操作系统会创建一个task_struct的数据结构用于存放这些,此时在内中的这些数据被称为是一个进程&lt;br&gt;
    
    </summary>
    
      <category term="Linux基础" scheme="http://smartyhero.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="linux" scheme="http://smartyhero.com/tags/linux/"/>
    
      <category term="进程" scheme="http://smartyhero.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>grep和正则表达式</title>
    <link href="http://smartyhero.com/2018/05/10/grep-pattern/"/>
    <id>http://smartyhero.com/2018/05/10/grep-pattern/</id>
    <published>2018-05-10T10:50:36.000Z</published>
    <updated>2018-05-17T11:19:11.926Z</updated>
    
    <content type="html"><![CDATA[<p>Global search REgular expression and Print out the line文本过滤工具,英文名REGEX,无论从从中文还是英文,我们好像都无法从字面上来解释这个名词,不过有我个人对正则的理解<br><a id="more"></a></p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>​    全称:Global search REgular expression and Print out the line文本过滤工具,按行显示出含有某个特定字符的工具,该工具最大的特点肯定是支持正则表达式,他还有两个按名字上来看算是一奶同胞的兄弟,egrep和fgrep,egrpe支持扩展正则表达式,而fgrep就不同了,他不支持正则表达式,由于grep提供了两个选项-F和-E分别可以完成fgrep和egrep的功能,所以这里仅讨论一下grep的用法</p><p>​    grep语法:<em>grep [OPTION]… PATTERN [FILE]…</em></p><p>​    首先用一个最简单的例子展示一下这个工具的作用</p><p><img src="/images/grep-01.png" alt=""></p><p>​    </p><p>​    得解释一下,这个匹配到的字符被标红了,并不是工具默认就有的选项,而是需要特定的选项–color=auto,才能将匹配的字符标红的,我这里用的是CentOS7,系统默认创建了该命令的别名grep=”grep –color=auto”,</p><p>​    下面主要列一下这个工具的常用选项:</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-i</td><td>不区分大小写</td></tr><tr><td>-o</td><td>仅显示匹配到的字符,默认会显示匹配到字符的整行</td></tr><tr><td>-w</td><td>匹配整个单词</td></tr><tr><td>-E</td><td>支持扩展的正则表达式</td></tr><tr><td>-v</td><td>显示没有被匹配到的行</td></tr><tr><td>-n</td><td>显示行号</td></tr><tr><td>-c</td><td>统计匹配到的行数</td></tr><tr><td>-G</td><td>使用基本的正则表达式</td></tr><tr><td>-F</td><td>不使用正则表达式</td></tr><tr><td>-P</td><td>使用Perl的正则表达式</td></tr><tr><td>-e</td><td>或者 str1 -e str2即包含str1或者str2</td></tr><tr><td>-q</td><td>静默模式,即无论匹配到还是没有匹配到都不显示</td></tr><tr><td>-A n</td><td>显示匹配到的行和其之后的n行</td></tr><tr><td>-B n</td><td>显示匹配到的行和其之前的n行</td></tr><tr><td>-C</td><td>显示匹配到的行和其之前的n行之后的n行</td></tr></tbody></table><p>下面详细介绍一下以上的某几个选项</p><p>​    -w:grep不会去验证一串英文字母到底是不是单词,而是仅仅把英文字母的组合还有含有下划线的英文字母组合当成是一个单词,比如grep-is-good,grep_is_good会认为grep_is_good认为是一个单词,而grep-is-good会认为是三个单词,下面来看一下两个示例的对比</p><p><img src="/images/grep-02.png" alt=""></p><p>首先查看了grep1中的内容,4行内容都含有good字符串,在不加任何选项去匹配的时候,四个都匹配到了,</p><p>而加了-w之后,只匹配到了good行和grep-is-good行,因此看来grep把grep_is_good也看成了一个单词,因此并没有匹配到</p><p>​    -q:静默模式,这个选项主要是用在写脚本的时候,当判断某一个文件中是否包含有某个字符就比较有用了,无论检查到没有他都不会在屏幕上显示内容,当然bash提供了$?这个变量,他保存了上一条命令的执行状态,0代表成功,1-255表示各种错误,当然你觉得-q不够装逼还可以用重定向将结果重定向到/dev/null中</p><p>​    -A,-B,-C:当然有些人会觉得这三个选项没有意义,想看哪行直接匹配哪行就行了嘛,干嘛还整这个,其实在 有些特定的场景中,我们无法提前获得你要匹配到的行的,这样就可以通过这三个选项解决了</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>​    英文名REGEX,无论从从中文还是英文,我们好像都无法从字面上来解释这个名词,下面说一下我对正则表达式的理解:正则表达式程序将某一些一些字符(在正则表达式中称作元字符)或者字符组合予以特殊含义,以此通过将这些特殊字符的组合来表达含有某种格式的字符串,这样就可以从一些杂乱的字符集合中找到我们想要的内容,然后通过其他的程序对这些字符串进行处理或者利用,正则表达式是通用的,常见的编程语言,以及某些工具,软件都支持正则表达式,因此这也算是一个挺重要的东西,在Linux下可以查看regex第七章的man帮助</p><p>​    <strong>正则表达式引擎</strong>:</p><p>​    就是负责做这件事的程序模块,虽然说正则表达式是通用的,但是在某些细节上不同的编程语言,工具等,还是有一些细微的差距的,就像是浏览器一样,虽然Chrome,Firefox,IE都可以打开网页,但是可能同一个网页在不同的浏览器上的效果展示会不同.这个是很正常的,不过正则表达式肯定没有浏览器兼容那么恶心</p><p>​    <strong>元字符的分类</strong>:</p><p>​    字符匹配,匹配次数,位置锚定,分组</p><p>下面将常用的元字符做总结:</p><p><strong>字符匹配:</strong></p><p>​    .:代表任意一个</p><p>​    []:匹配指定范围内的任意一个字符</p><p>​        例:[a-z],[A-Z],[0-9],[abcd]…</p><p>​    ^:表示非该范围内的任意字符,注意这个^的用法,下面还会介绍他的另一个功能</p><table><thead><tr><th>元字符</th><th>作用</th></tr></thead><tbody><tr><td>.</td><td>任意的一个字符</td></tr><tr><td>[]</td><td>该范围内的任意一个字符,可以使用-分隔表示范围:比如[a-z]表示所有的小写字母,当然需要匹配-的时候需要用\转义,即-</td></tr><tr><td>^</td><td>非,表示非某个字符或者某一个范围内的字符,当然^还有另外的一个作用后面会在其他分类中介绍</td></tr><tr><td>[:digit:]</td><td>任意一个数字和0-9表示的含义一样,注意这个中括号,是元字符本身的一部分,并不是上面指定范围的[],例如想表示0-9和-的任意一个字符需要写成[[:digit:]\-],而不能写成[:digit:\-]</td></tr><tr><td>[:alpha:]</td><td>表示任意一个大小写字母</td></tr><tr><td>[:upper:]</td><td>表示任意一个大写字母</td></tr><tr><td>[:lower:]</td><td>表示任意一个小写字母</td></tr><tr><td>[:alnum:]</td><td>表示任意一个大小写字母和数字</td></tr><tr><td>[:space:]</td><td>表示一个空格字符或者一个tab字符</td></tr><tr><td>[:punct:]</td><td>表示任意一个标点符号</td></tr></tbody></table><p>​    注意:以上这类[:digit:]…的元字符可能是Linux中特有的,其他地方的正则表达式并不一定含有这些元字符</p><p><strong>次数匹配:</strong></p><table><thead><tr><th>元字符</th><th>作用</th></tr></thead><tbody><tr><td>*</td><td>表示其所修饰的字符可以出现任意次,即0次或者多次</td></tr><tr><td>\?</td><td>表示0次或者1次</td></tr><tr><td>\{n\}</td><td>明确的表示n次</td></tr><tr><td>\{n,\}</td><td>表至少n次,即n次或者更多次</td></tr><tr><td>\{n,m\}</td><td>表示n次到m次之间</td></tr><tr><td>\{,n\}</td><td>n次之内,即表示0次到n次</td></tr></tbody></table><p><strong>位置锚定:</strong></p><table><thead><tr><th>元字符</th><th>作用</th></tr></thead><tbody><tr><td>^</td><td>表示其后面的字符属于一行的开头,如果有[]要写在[]的外面,否则会表示成上面说的非[]中的字符</td></tr><tr><td>$</td><td>表示其之前的字符是一行的结尾</td></tr><tr><td>\&lt;</td><td>表示其后面的字符是单词的首部,例如\&lt;w表示以w开头的单词</td></tr><tr><td>\&gt;</td><td>表示其前面的字符是单词的尾部,例如d\&gt;表示以d结尾的单词</td></tr><tr><td>\b</td><td>表示单词的边界,即,既可以表示头部也可以表示尾部</td></tr></tbody></table><p><strong>分组:</strong></p><p>​    分组其实就是用()包起来的字符被看做是一个分组,分组的主要作用就是当后面要匹配的字符和前面已经匹配到的字符相同时就可以使用()将前面的字符分组,在后面使用\n来表示,n代表的是第几个分组,从左数第几个左括号就表示的是第几个分组,比如(ab(cd)),\1代表的是abcd\2代表的是cd,一定要分清,分组\n代表的是前面匹配到的内容,而不是模式本身,</p><p>​    另外一个和分组类似的就是|,他代表的是或的关系,比如(a|b)这就代表a或者b当然如果后面不需要使用分组其实他的作用和[ab]的作用是一样的,需要注意的一点就是,b|dig,这个代表的是b或者dig,而不是我们想象的big或者dig,如果想代表big或者dig就需要使用(b|d)ig或者[bd]ig了</p><p>​    以上就是我们经常会用到的正则表达式的元字符,有了这些基础,这里就可以讨论一下正则表达式的另外一个重要的概念:<strong>贪婪模式</strong>和<strong>懒惰模式</strong></p><p>​    <strong>贪婪模式:</strong>顾名思义,就是比较贪心,他会尽量的多的去匹配字符</p><p>​    <strong>懒惰模式:</strong>肯定是和贪婪模式相反了,他是只要匹配到就可以了</p><p>​    比如说有这样一个字符串:abcddddddd,我们使用这个正则表达式:abcd*,如果是贪婪模式他会匹配到abcddddddd整个字符串,而懒惰模式则只匹配到abcd就不在继续匹配了,在Linux中默认使用的是贪婪模式</p><p>​    看了资料说将懒惰模式变成贪婪模式是在其后面加\?比如说上面的例子如果写成abcd*\?就代表的是处于懒惰模式即只匹配到abcd,但是这种写法在Linux中我使用grep测试这样写好像并不灵验,如果想匹配更少的次数,可以使用次数匹配</p><p>在上面讨论grep的时候提到过egrep即<strong>扩展的正则表达式</strong>,其实这个很简单啦,就是使用扩展的正则表达式后大多数元字符不用加\转义了,但是有个别的比如\&lt;,\&gt;,\b还是需要加的</p><p>最后用几个示例感受一下正则表达式的魅力</p><p>​    匹配手机号:</p><p>​    <img src="/images/grep-03.png" alt=""></p><p>​    匹配ip地址:</p><p><img src="/images/grep-04.png" alt=""></p><p>正则表达式非常灵活,有很多种写法,而且对于不同的场景也许需要不同的调整,没有固定的写法,以上内容为个人学习总结,存在各种不尽人意的地方还望大家多多指正</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Global search REgular expression and Print out the line文本过滤工具,英文名REGEX,无论从从中文还是英文,我们好像都无法从字面上来解释这个名词,不过有我个人对正则的理解&lt;br&gt;
    
    </summary>
    
      <category term="Linux基础" scheme="http://smartyhero.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="grep" scheme="http://smartyhero.com/tags/grep/"/>
    
      <category term="正则表达式" scheme="http://smartyhero.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="文本处理三剑客" scheme="http://smartyhero.com/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    
  </entry>
  
</feed>
